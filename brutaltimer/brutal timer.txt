timer 1 is 50ns
timer 2 is 1us
timers are exclusive, it is either timer 1 or timer 2 that runs
timer value is 32-bits

---------------- OPTION 1 (restart is handled by start)

C0x0 write	reset timer X
C0x1 write #1	start timer 1
C0x1 write #2	start timer 2
C0x1 read	bit 7=0 : timer X not started or paused
	bit 7=1 : timer X started
C0x2 write	pause timer X
C0x4 read 7-0	read timer X value
C0x5 read 15-8
C0x6 read 23-16
C0x7 read 31-24

-----------------

At boot time, timer value is undefined (this is what I envision but I can be wrong)
- reset timer: inits the timer value to 00000000
- start timer (1 or 2): increments the timer value at frequency 50ns or 1us. It the timer was paused/stopped, then it restarts again without resetting the value to 0
- pause timer: pauses/stops the increment of the timer value
- read timer: returns the current 32-bit timer value. The user must have paused/stopped the timer before reading it.

-----------------

From a user's perspective:

- INIT
	STA	$C080,X
	LDA	#1
	STA	$C081,X

- READ
	STA	$C082,X	; pause first
	LDA	$C084,X	; read 32-bit value
	STA	$00
	LDA	$C085,X	
	STA	$01
	LDA	$C086,X
	STA	$02
	LDA	$C087,X
	STA	$03
	LDA	#1	; restarts the timer
	STA	$C081,X	; without resetting the value

- STOP
	LDA	$C081,X
	BPL	end
	STA	$C081,X
end	RTS


----------------------------------------------------
---------------- OPTION 2 (resume is handled by pause)

C0x0 write	reset timer X
C0x1 write #1	start timer 1
C0x1 write #2	start timer 2
C0x1 read	bit 7=0 : timer X not started or paused
	bit 7=1 : timer X started
C0x2 write	pause/resume timer X
C0x4 read 7-0	read timer X value
C0x5 read 15-8
C0x6 read 23-16
C0x7 read 31-24

-----------------

At boot time, timer value is undefined (this is what I envision but I can be wrong)
- reset timer: inits the timer value to 00000000
- start timer (1 or 2): increments the timer value at frequency 50ns or 1us.
- pause timer: pauses/stops/resules the increment of the timer value. Restarts does not reset the timer value.
- read timer: returns the current 32-bit timer value. The user must have paused/stopped the timer before reading it.

-----------------

From a user's perspective:

- INIT
	STA	$C080,X	; inits value to 0
	LDA	#1	; starts timer 1
	STA	$C081,X

- READ
	STA	$C082,X	; pauses first
	LDA	$C084,X	; read 32-bit value
	STA	$00
	LDA	$C085,X	
	STA	$01
	LDA	$C086,X
	STA	$02
	LDA	$C087,X
	STA	$03
	STA	$C082,X	; restarts the timer

- STOP
	LDA	$C081,X	; is it started?
	BPL	end	; no
	STA	$C082,X	; yes, stop it
end	RTS

---------------- Plamen says

Yes , in this hardware it is possible to have 2 timers with 32 bit resolution,  one display that can display one of the timer in HEX . The input freq of first timer is fixed and depend of Quartz mounted on PCB ( 20Mhz ) , another is depend of second  Quartz on PCB or selectable from 1Mhz ( made from first timer div 20 ) 1.xx from mainboard ( to be accurate with system clock ) or 3.5Mhz ( from system ) .Also have NMI or IRQ ( if you find any practical use ot it ) .

I can design with more complex CPLD more extended Timer card with many timers and functionality of set any clock or events and display many counters in native DEC format or any other if think that this will be usefull or can 'be interested .

---------------- OPTION 3 (restart is handled by start)

** NEW **
T1 = Timer 1
T2 = Timer 2
- reordering of commands
- stop command added (probably useless)
- wide use of values #0/#1/#2 to set the timer when needed
- new command to set frequency to T2
- new command to start/stop display of frequency
- new addresses to read a timer value

C0x0 write #0	reset T1 and T2 (reset value to 0)
C0x0 write #1	reset T1 (reset value to 0)
C0x0 write #2	reset T2 (reset value to 0)

C0x1 write #0	start or resume T1 and T2
C0x1 write #1	start or resume T1
C0x1 write #2	start or resume T2

C0x1 read	bit 7=0 : T1 not started or paused
	bit 7=1 : T1 started
	bit 6=0 : T2 not started or paused
	bit 6=1 : T2 started

C0x2 write #0	pause T1 and T2
C0x2 write #1	pause T1
C0x2 write #2	pause T2

C0x3 write #0	stop T1 and T2
C0x3 write #1	stop T1
C0x3 write #2	stop T2

C0x4 write #0	set T2 frequency to 1 MHz
C0x4 write #1	set T2 frequency to 1.xx MHz from mainboard
C0x4 write #2	set T2 frequency to 3.5 MHz from system

C0x4 read	bits 7-6
	00: T2 frequency is 1 MHz
	01: T2 frequency is 1.xx MHz from mainboard
	10: T2 frequency is 3.5 MHz from system

C0x5 write #0	stop display
C0x5 write #1	show T1 display
C0x5 write #2	show T2 display

C0x8 read 7-0	read T1 value
C0x9 read 15-8
C0xA read 23-16
C0xB read 31-24

C0xC read 7-0	read T2 value
C0xD read 15-8
C0xE read 23-16
C0xF read 31-24

-----------------

From a user's perspective:

- INIT
	LDA	#0	; stop timers
	STA	$C083,X
	LDA	#0	; reset values of T1 and T2 to 0
	STA	$C080,X
	LDA	#1	; start T1
	STA	$C081,X
	LDA	#2	; set T2 frequency to 3.5 MHz from system
	STA	$C084,X
	LDA	#2	; start T2
	STA	$C081,X
	
- READ T1
	LDA	#1	; pause T1
	STA	$C082,X
	LDA	$C088,X	; read 32-bit value
	STA	$00
	LDA	$C089,X	
	STA	$01
	LDA	$C08A,X
	STA	$02
	LDA	$C08B,X
	STA	$03
	LDA	#1
	STA	$C082,X	; resume T1

- READ T2
	LDA	#2	; pause T2
	STA	$C082,X
	LDA	$C08C,X	; read 32-bit value
	STA	$00
	LDA	$C08D,X	
	STA	$01
	LDA	$C08E,X
	STA	$02
	LDA	$C08F,X
	STA	$03
	LDA	#2
	STA	$C082,X	; resume T2

- STOP T1
	LDA	$C081,X	; is T1 started?
	BPL	end	; no
	LDA	#1
	STA	$C082,X	; yes, stop it
end	RTS

- STOP T2
	LDA	$C081,X	; is T2 started?
	ASL
	BPL	end	; no
	LDA	#2
	STA	$C082,X	; yes, stop it
end	RTS


