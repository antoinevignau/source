/************************************************************************* Window.c** Copyright (c)  1990* Apple Computer, Inc.* All Rights Reserved.** This file contains the code which implements  * windows in the scanner program.************************************************************************/#include <intmath.h>#include <memory.h>#include <types.h>#include <quickdraw.h>#include <qdaux.h>#include <resources.h>#include <window.h>#include <misctool.h>#include <control.h>#include <menu.h>#include <malloc.h>#include "Scan.h"#define xRulerInset 10#define yRulerInset 10extern scannerWindowDef	sWindowDef;extern unsigned int     staggerCount;extern PicHndl			previewRuler;void updatePreviewWindow();extern GrafPortPtr		previewWindowPtr;extern GrafPortPtr		settingsWindowPtr;/* grayscale pallette */int cTable[16]= {0x000,0x111,0x222,0x333,0x444,0x555,0x666,0x777,				 0x888,0x999,0xAAA,0xBBB,0xCCC,0xDDD,0xEEE,0xFFF};/* standard pallette */int defCTable[16] = {0x000,0x777,0x841,0x72C,0x00F,0x080,0xF70,0xD00,					 0xFA9,0xFF0,0x0E0,0x4DF,0xDAF,0x78F,0xCCC,0xFFF};/*************************************************************************************************/static CtlRecHndl makeBoxCtl(theWindow)GrafPortPtr	theWindow;{	CtlRecHndl	boxCtl;	static Rect	boxRect = { YINSET,XINSET,YINSET+(11*vPPI)+1,XINSET+((85*hPPI)/10)+1 };	static int	boxData[] = {	YINSET,					/* min Y */								XINSET,					/* min X */								YINSET+(14*vPPI)+1,		/* max Y */								XINSET+((85*hPPI)/10)+1,/* max X */								10,						/* minimum height */								16,						/* minimum width */								1,						/* grid Y */								1 };					/* grid X */	static int	boxColorTbl = 0x00B0;	extern void BoxProc();	boxCtl = NewControl(theWindow,&boxRect,NULL,0x0006,0x0303,boxData,BoxProc,NULL,&boxColorTbl);/*						|		  |		   |	|	   |	  |		  |		  |	   ColorTable						|		  |		   |	|	   |	  |		  |		  RefCon						|		  |		   |	|	   |	  |		  DefProc						|		  |		   |	|	   |	  custom data						|		  |		   |	|	   width/heighth of knobs						|		  |		   |	ctlFlag						|		  |		   title pointer						|		  control rectangle						window pointer	*/	if(_toolErr)		ErrorWindow(0,NULL,_toolErr);	return(boxCtl);}openPreview(){#define	bufferSize	968L	Handle		tempHandle, bufferHandle;	LocInfoPtr	theLocInfo;	GrafPortPtr	theWindow;	Rect		*theRect;	int			fontWidth, rulerDepth1,rulerDepth2;	unsigned	i;	if(previewWindowPtr != NULL) {		SelectWindow(previewWindowPtr);	} else {		bufferHandle = NewHandle(bufferSize,_ownerid,attrFixed,NULL); 		if(_toolErr != 0) {				AlertWindow(4,NULL,(long) noMemAvailable);		} else { 			tempHandle = NewHandle((long)sizeof(LocInfo),_ownerid,attrFixed,NULL);			theLocInfo = (LocInfoPtr)*tempHandle;			theLocInfo->portSCB = (sWindowDef.bitsPerPixel == 4) ? 0x80 : 0;			theLocInfo->ptrToPixImage = *bufferHandle;			theLocInfo->width = (104 * sWindowDef.bitsPerPixel + 7)/8;			theLocInfo->boundsRect.v1 = 0;			theLocInfo->boundsRect.h1 = 0;			theLocInfo->boundsRect.v2 = 149;			theLocInfo->boundsRect.h2 = 104;					theWindow = NewWindow2(NULL,theLocInfo,updatePreviewWindow,NULL,2,PreviewWindow,rWindParam1);			SetPort(theWindow);			previewWindowPtr = theWindow;				SetDataSize(180,120,theWindow);			makeBoxCtl(theWindow);	/* go add the custom control */			if((previewRuler == NULL)) {				fontWidth = 8;				SetOrigin(0,0);				GetPortRect(&theRect);				rulerDepth1 = fontWidth+7;				rulerDepth2 = (2*fontWidth)+7;					previewRuler = OpenPicture(&theRect);					MoveTo(XINSET-XOFFSET,YINSET);				/* draw the vertical ruler first */				/* draw hash marks */					for(i = 0; i < 14; ++i) {						Move(0,vPPI>>1);	/* move to first hash mark */						Line(-3,0);	/* draw half-inch mark */						Move(-4,vPPI>>1);	/* move to full hash mark */						Line(7,0);	/* draw full-inch mark */					}					Move(0,-((vPPI*14)-4));		/* move back to top of ruler + 4 to center numerals */				/* mark the ruler divisions */					for(i = 2; i < 10; i += 2) {						Move(-rulerDepth1,vPPI<<1);						DrawChar('0'+i);						Move(7,0);					}					for(i = 10; i < 14; i += 2) {						Move(-rulerDepth2,vPPI<<1);						DrawChar('1');						DrawChar('0'+(i-10));						Move(7,0);					}					Move(0,(vPPI*2)-4);	/* position pen to bottom right corner */				/* then draw the ruler rectangle */					Line(-27,0);	/* bottom */					Line(0,-(vPPI*14));	/* left side */					Line(27,0);		/* top */					Line(0,(vPPI*14));	/* right side of ruler box */				/* now draw the ruler along the top */					Move(XOFFSET,-(vPPI*14+YOFFSET));	/* vertical ruler stopped at bottom right corner */								/* draw the hash marks */					for(i = 0; i < 8; ++i) {						Move(hPPI>>1,0);						Line(0,-2);						Move(hPPI>>1,-2);						Line(0,4);					}					Move(hPPI>>1,0);	/* the 8 1/2 mark */					Line(0,-2);					Move(-((hPPI*8)+(hPPI>>1)-(fontWidth>>1)),2);	/* reposition back to start of ruler */								/* draw the ruler divisions */					for(i = 2; i < 10; i += 2) {						Move((hPPI<<1)-fontWidth,-5);						DrawChar('0'+i);						Move(0,5);					}					Move((hPPI>>1)-(fontWidth>>1),0);	/* move to lower-right corner of ruler */								/* draw the ruler frame */					Line(0,-14);					Line(-((hPPI*8)+(hPPI>>1)),0);					Line(0,14);					Line(((hPPI*8)+(hPPI>>1)),0);									ClosePicture(); 			}			EnableMItem(CloseID);		}	}}#if 0	/* is this used? *//***********************************************************************/void drawMousePos(){	MouseRec	thisMouseRec;	CtlRecHndl	ctlHandle;	GrafPortPtr thisPort;	Pointer		theXArrayList[1];	Pointer		theYArrayList[1];	static char	xString[] = {"0000"};	static char	yString[] = {"0000"};		theXArrayList[0] = xString;	theYArrayList[0] = yString;		if(settingsWindowPtr != 0){		thisMouseRec = ReadMouse();	/* 	thisPort = GetPort();		SetPort(settingsWindowPtr); */		/*			ctlHandle = GetCtlHandleFromID(settingsWindowPtr,WinXEndText);		Int2Dec(thisMouseRec.xPos,xString,4,FALSE);		SetCtlParamPtr(theXArrayList);		DrawOneCtl(ctlHandle);			ctlHandle = GetCtlHandleFromID(settingsWindowPtr,WinYEndText);		Int2Dec(thisMouseRec.yPos,yString,4,FALSE);		SetCtlParamPtr(theYArrayList);		DrawOneCtl(ctlHandle);	*/	/*	SetPort(thisPort); */	}	}/************************************************************************* doInPreview** This routine draws the contents of all the windows.************************************************************************/void    doInPreview(mouseStart)Point	mouseStart;{	CtlRecHndl	ctlHandle;	Pointer		theXArrayList[1];	Pointer		theYArrayList[1];	static char	xString[] = {"0000"};	static char	yString[] = {"0000"};	Rect		limitRect,slopRect;	Point		mouseEnd;	word		dragFlag, penMode;	Long		changePos;	static char	test[32]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,					0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};	static char	penMaskUnDraw[32]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,					0x00,0x00,0x00,0x00f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};		theXArrayList[0] = xString;	theYArrayList[0] = yString;	penMode = GetPenMode();/*	SetPenMode(modeXOR);	SetPenMask( */	if(((dragRect.v1)|(dragRect.h1)|(dragRect.v2)|(dragRect.h2))) {		FrameRect(&dragRect);	}	GetPortRect(&slopRect);	limitRect.v1 = slopRect.v1 + YINSET-1;	limitRect.h1 = slopRect.h1 + XINSET-4;	limitRect.v2 = slopRect.v2 -5;	limitRect.h2 = slopRect.h2 -109;	GlobalToLocal(&mouseStart);		if(mouseStart.h < limitRect.h1) mouseStart.h = limitRect.h1;	if(mouseStart.v < limitRect.v1) mouseStart.v = limitRect.v1;	if(mouseStart.h > limitRect.h2) mouseStart.h = limitRect.h2;	if(mouseStart.v > limitRect.v2) mouseStart.v = limitRect.v2;	/*	ctlHandle = GetCtlHandleFromID(settingsWindowPtr,WinYStartText);	Int2Dec(mouseStart.v,yString,4,FALSE);	SetCtlParamPtr(theYArrayList);	DrawOneCtl(ctlHandle);	ctlHandle = GetCtlHandleFromID(settingsWindowPtr,WinXStartText);	Int2Dec(mouseStart.h,xString,4,FALSE);	SetCtlParamPtr(theXArrayList);	DrawOneCtl(ctlHandle);*/		SetRect(&dragRect,mouseStart,mouseStart.h+2,mouseStart.v+2);	dragFlag = 0x0424; /* minimum of 4 pixels, return the final rect, drag rubberband rectangle */		DragRect(drawMousePos,test,mouseStart.h,mouseStart.v,&dragRect,&limitRect,&slopRect,dragFlag);			FrameRect(&dragRect);	SetPenMode(penMode);	}#endif/************************************************************************* drawThisWindow** This routine draws the contents of all the windows.************************************************************************/void    drawThisWindow(){    DrawControls(GetPort());}    /************************************************************************* doCloseTop** This routine closes the topmost window.  We do a little work to* prevent the main window from being closed.************************************************************************/void    doCloseTop(){    GrafPortPtr     tempWin;	LocInfoPtr		theLocInfo;	char			**nameHndl;    unsigned int    k;    tempWin = FrontWindow();	if(tempWin == previewWindowPtr) {		previewWindowPtr = NULL;	}	if(tempWin == settingsWindowPtr) {		settingsWindowPtr = NULL;	}		    if(tempWin != NULL) { 		if (theLocInfo = (LocInfoPtr)GetWRefCon(tempWin)) {			DisposeHandle(FindHandle(theLocInfo->ptrToPixImage));			DisposeHandle(FindHandle(theLocInfo));		}		nameHndl = (char **) GetWTitle(tempWin);	/* was the name allocated by us? */		if(!((long) nameHndl & 0x80000000))	/* not if it's a handle */			free(nameHndl);				/* else dipose of it */		CloseWindow(tempWin);    }		if(!FrontWindow())		DisableMItem(CloseID);	}/************************************************************************* openThisWindow** This routine either opens the specified window or brings it to the top* if it is already open.** If it is not open, we open it with NewWindow2 invisibly, adjust the window's* location and then show and select the window.************************************************************************/GrafPortPtr	openThisWindow(ctlid)unsigned long    ctlid;{    GrafPortPtr     wptr;	wptr = NewWindow2(NULL, NULL, drawThisWindow, NULL, 2, ctlid, rWindParam1);	if (ctlid < AppWindow) {		MoveWindow (50 + 8 * staggerCount, 50 + 8 * staggerCount, wptr);		staggerCount++;		staggerCount &= 0x0F;	}	SelectWindow(wptr);	return(wptr);}     /************************************************************************* setupWindows - initializes window stuff prior to entering event loop************************************************************************/void    setupWindows(){	extern void doSettingsItem();		doSettingsItem();	return;}/************************************************************************* updateScannerWindow()** updates the bit mapped windows with the scanned data.************************************************************************/void    updateScannerWindow(){	LocInfoPtr theSrcLoc = (LocInfoPtr)GetWRefCon(GetPort());	PPToPort(theSrcLoc,&theSrcLoc->boundsRect,0,0,notCopy);	if (_toolErr)		ErrorWindow(0,NULL, _toolErr);}/************************************************************************* updatePreviewWindow()** updates the bit mapped windows with the scanned data.************************************************************************/void    updatePreviewWindow(){	Rect 			theRect, pageRect;		LocInfoPtr theSrcLoc = (LocInfoPtr)GetWRefCon(GetPort());		GetPortRect(&theRect);		DrawPicture(previewRuler,&theRect);/*	if((dragRect.h1|dragRect.h2|dragRect.v1|dragRect.v2) != 0) {		FrameRect(&dragRect);	}*/			pageRect.v1 = YINSET-1;	pageRect.v2 = YINSET + (14 * vPPI) + 2;	pageRect.h1 = XINSET-1;	pageRect.h2 = XINSET + (8 * hPPI) + (hPPI >> 1) + 2;	SetSolidPenPat(7);	FrameRect(&pageRect);	if (_toolErr)		ErrorWindow(0,NULL,_toolErr);	SetSolidPenPat(0);	DrawControls(previewWindowPtr);}/************************************************************************* doOpenImage*************************************************************************/void doOpenImage(dataWidth, dataLength, bufferHandle)unsigned long 	dataWidth, dataLength;Handle 			bufferHandle;{	char			*windowName;	LocInfoPtr 		theLocInfo;	GrafPortPtr		theWindow;	Handle 			tempHandle;	int 			mode;	int				pixelWidth;	static char windNum = '1';	/* Check the screen mode and multiply by 2 if 640 */	mode = (GetMasterSCB() & 0x0080) ? 1 : 2;	pixelWidth = (dataWidth * 8) >> mode;	tempHandle = NewHandle((long)sizeof(LocInfo),_ownerid,attrFixed,NULL);	theLocInfo = (LocInfoPtr)*tempHandle;	theLocInfo->portSCB = (mode == 2) ? 0x00 : 0x80;	theLocInfo->ptrToPixImage = *bufferHandle;	theLocInfo->width = dataWidth;	theLocInfo->boundsRect.v1 = 0;	theLocInfo->boundsRect.h1 = 0;	theLocInfo->boundsRect.v2 = dataLength;	theLocInfo->boundsRect.h2 = pixelWidth;		windowName = malloc(12);	/* get memory for window title */	memcpy(windowName,"\p Untitled  ",12);	windowName[10] = windNum;	if(++windNum > '9')			/* adjust window number for next time through */		windNum = '1';	theWindow = NewWindow2(windowName,theLocInfo,updateScannerWindow,NULL,2,ImageWindow,rWindParam1);	SetPort(theWindow);	SetDataSize(pixelWidth,(short)dataLength,theWindow);		EnableMItem(CloseID);	free(windowName);}