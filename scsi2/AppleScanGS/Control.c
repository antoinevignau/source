/************************************************************************ Control.c** Copyright (c)  1990* Apple Computer, Inc.* All Rights Reserved.** This file contains the code which implements the * procedures for the various controls.***********************************************************************/#define rulerXoffset 0#define rulerYoffset 0#define previewRes	75#define   maxX  10200#define   maxY  16800#define	  yOrg 10#define   xOrg 36#include <control.h>#include <intmath.h>#include <types.h>#include <list.h>#include <locator.h>#include <quickdraw.h>#include <qdaux.h>#include <event.h>#include <lineEdit.h>#include <menu.h>#include <memory.h>#include <resources.h>#include <window.h>#include "Scan.h"#include "Scanner_GSOS.h"extern scannerWindowDef	sWindowDef;extern GrafPortPtr		previewWindowPtr;extern void updateScannerWindow();extern void updatePreviewWindow();/* called by TrackControl when the mouse is held down in one of the scroll controls */pascal void scrollAction(partCode,ctrlHndl)int		partCode;Handle	ctrlHndl;{	int	currentValue;		if(partCode) {	/* only do the work if the part code is valid */		currentValue = GetCtlValue(ctrlHndl);	/* get the current value */		switch(partCode) {	/* which part is active? */			case downArrow:	/* right arrow */				if(++currentValue > 255)	/* make sure we stay within the value bounds */					currentValue = 255;				break;			case upArrow:	/* left arrow */				if(--currentValue < 0)					currentValue = 0;				break;			case pageDown:	/* right paging region */				if((currentValue += 8) > 255)					currentValue = 255;				break;			case pageUp:	/* left paging region */				if((currentValue -= 8) < 0)					currentValue = 0;				break;		}		SetCtlValue(currentValue, ctrlHndl);	}	return;}word getResolutionPopUp(theControlHandle)Handle	theControlHandle;{	static int resTable[] = {0, 75, 100, 150, 200, 300};	return(resTable[GetCtlValue(theControlHandle)]);}long doGetXYPos( xStart,xEnd,yStart,yEnd)unsigned long	*xStart,*xEnd,*yStart,*yEnd;{	CtlRecPtr		boxCtl;	Rect			*boxRect;	unsigned		i;	unsigned long	temp, deltaX;	if(!previewWindowPtr) {	/* if preview window has not been opened... */		*xStart = *yStart = 0;	/* use default values to define page */		*xEnd = 10200;	/* 1200 * 8.5 inches */		*yEnd = 13200;	/* 1200 * 11 inches */	} else {		boxCtl = *GetWControls(previewWindowPtr);	/* get the control handle from the window record */		boxRect = &(boxCtl->ctlRect);	/* make a pointer to the control's rect */				*xStart = ((long) (boxRect->h1 - XINSET) * 1200) / hPPI;		*xEnd   = ((long) (boxRect->h2 - XINSET) * 1200) / hPPI;		*yStart = ((long) (boxRect->v1 - YINSET) * 1200) / vPPI;		*yEnd   = ((long) (boxRect->v2 - YINSET) * 1200) / vPPI;	}		if(*yEnd < *yStart) {		/* make sure that y is in the increasing direction */		temp = *yEnd;		*yEnd = *yStart;		*yStart = temp;		}	if(*xEnd < *xStart){		/* make sure that x is in the increasing direction */		temp = *xEnd;		*xEnd = *xStart;		*xStart = temp;		} 				return (*yEnd - *yStart);	/* scanlength */}long doFixXPos( xStart,xEnd,yStart,yEnd,xres)unsigned long	*xStart,*xEnd,*yStart,*yEnd;word	xres;{	unsigned long	chunkiness, fixAmount;	unsigned long   remainder, diff, deltaX;	diff = (Long)(*xEnd - *xStart);	chunkiness = 8*xres;	deltaX = diff%chunkiness;	fixAmount = chunkiness - deltaX;		if(deltaX != 0) {		if(*xEnd + fixAmount > maxX) {			if(fixAmount >= *xStart) {				*xStart = 0;				*xEnd = maxX;			} else {				*xStart -= fixAmount;			}		} else {			*xEnd += fixAmount;		}	}	return(*xEnd - *xStart);	/* return scanWidth */}doGetBrightness(){	return(GetCtlValue(GetCtlHandleFromID(NULL,BrightnessScroll)));	}doGetContrast(){	return(GetCtlValue(GetCtlHandleFromID(NULL,ContrastScroll)));	}doGetThreshold(){	return(GetCtlValue(GetCtlHandleFromID(NULL,ThresholdScroll)));	}doGetImageComposition(){	return(GetCtlValue(GetCtlHandleFromID(NULL,CompositionPopUp))-1);	}doGetBitsPerPixel(scanType)byte scanType;{	byte dpi;	switch(scanType){		case 0:			dpi = 1;			break;		case 1:			dpi = 1;			break;		case 2:			dpi = 4;			break;		}	return(dpi);}#if 0	/* currently not used, but will be when Data Chaining is implemented */static void invertImage(bufptr, buflen)unsigned	*bufptr;long 		buflen;	/* number of 16-bit words in buffer */{	GrafPortPtr	theWindow, oldPort;	char		*statText;	unsigned	cursNum = 0;	unsigned	counter = 0;	word		oldSCB;	int			thermX, thermY;	int			chunkSize, chunkCount;	static Rect thermRect = {50,10,60,229};	statText = "Now inverting the image";		/* remember the current GrafPort */	oldPort = GetPort();		/* draw the thermometer window */	theWindow = NewWindow2(NULL,NULL,NULL,NULL,2,ThermWindow,0x800E);	SetPort(theWindow);	MoveTo((240 - CStringWidth(statText)) >> 1 ,30);	DrawCString(statText);	FrameRect(&thermRect);	/* draw the thermometer frame */	SetSolidPenPat(7);	/* use a red pen */	thermX = 11; thermY = 51;	/* init drawing locations */	chunkSize = buflen / 217;	/* determine size to process before filling in a line */	chunkCount = 0;	SetMasterSCB((oldSCB = GetMasterSCB()) | 0x0100);	/* make sure cursor doesn't flicker */	do {		*bufptr ^= 0xffff;		++bufptr;		if(!(++counter & 0x1fff)) {			SetCursor(animCursor[++cursNum]);			if(!(cursNum < 7))	/* in other words, if cursNum >= 7 (but this produces better code) */				cursNum = -1;		}		if(++chunkCount == chunkSize) {			MoveTo(thermX++, thermY);	/* init the pen position */			Line(0,7);			chunkCount = 0;		}	} while(--buflen);	SetMasterSCB(oldSCB);	/* reset master SCB */	SetPort(oldPort);		/* reset the GrafPort */	CloseWindow(theWindow);	/* close the alert window */	SetSolidPenPat(0);		/* reset the pen back to black */}#endifvoid doScanButton(){	unsigned		*tempPtr;	Handle  		bufferHandle;	unsigned long	bufferSize, i, transferCount;	word 			xGSres, yGSres;	unsigned long 	scanLength,scanWidth;	unsigned long 	xStart,xEnd,yStart,yEnd;	unsigned long 	dataWidth, dataLength;	extern long 	doScan();	sWindowDef.windDescBlockLenMSB = 0;	sWindowDef.windDescBlockLenLSB = 0x28;	sWindowDef.windowIdentifier = 0;	xGSres = getResolutionPopUp(GetCtlHandleFromID(NULL,XResolutionPopUp));	yGSres = getResolutionPopUp(GetCtlHandleFromID(NULL,YResolutionPopUp));	sWindowDef.xResolution  = SwapBytes(xGSres);	/* we want the # of 1200ths of an inch in lsb>>msb */	sWindowDef.yResolution  = SwapBytes(yGSres);		scanLength = doGetXYPos(&xStart,&xEnd,&yStart,&yEnd);	scanWidth = doFixXPos(&xStart,&xEnd,&yStart,&yEnd,xGSres); 	sWindowDef.xUpperLeft = SwapWords(xStart);  	sWindowDef.yUpperLeft = SwapWords(yStart);	sWindowDef.width = SwapWords(scanWidth);	sWindowDef.length = SwapWords(scanLength);	sWindowDef.brightness = doGetBrightness();	sWindowDef.threshold = doGetThreshold();	sWindowDef.contrast = doGetContrast();	sWindowDef.imageComposition = doGetImageComposition();	sWindowDef.bitsPerPixel = doGetBitsPerPixel(sWindowDef.imageComposition);	sWindowDef.halfTone = SwapBytes(2); 	sWindowDef.paddingType = 3;	switch(xGSres){		case 75:			scanWidth += 16;			break;		case 150:			scanWidth += 8;			break;	}	dataWidth = (((scanWidth*xGSres)/1200) * (long) (sWindowDef.bitsPerPixel))/8;	/* in bytes */	dataLength = (scanLength*yGSres)/1200;	/* # of scan lines */				bufferSize = dataWidth * dataLength;	/* bytes per scan line * # of scan lines */	bufferHandle = NewHandle(bufferSize,_ownerid,attrFixed,NULL); 	if(_toolErr != 0) {			AlertWindow(4,NULL,(long) noMemAvailable);	} else {		WaitCursor();		transferCount = doScan(bufferHandle, bufferSize, &sWindowDef, dataWidth, dataLength);		doOpenImage(dataWidth, dataLength, bufferHandle);		InitCursor();	}}void doPreviewButton(){/*	format_call();	eject_call();	set_confg_parms();	set_format();	Assign_part();	arm_signal();	disarm_signal();	set_part_map();	reserve_unit();	release_unit();	send_diagnostics();		return_dev_status();	return_confg_parms();	return_wait();	return_format();	return_part_map();	return_last_cmd();		test_unit_rdy();	request_sense();	inquiry();	mode_sense();	get_wndow_parms();	extended_read();	get_data_status();		if(_toolErr != 0) {		AlertWindow(4,NULL,(long) noMemAvailable);	}	*/}