; from E16.ControloctlOwner	EQU		4octlRect	EQU		8octlFlag	EQU		16octlHilite	EQU		17octlValue	EQU		18octlColor	EQU		36ctlInVis	EQU		$0080				; invisible mask for any type of control recSize		EQU		$000C				; Return record size command.; from E16.Eventowhat		EQU		0owhere		EQU		10mouseUpEvt	EQU		$0002mUpMask		EQU		$0004; from E16.QuickDrawoportRect	EQU		16					; PortRect; from E16.WindowowFrame		EQU		210noPart		EQU		$0000fHilited	EQU		$0001				; Window is highlighted.fCtlTie		EQU		$0008				; Window state tied to controls.; from M16.Control MACRO&lab _DragRect&lab ldx #$1D10     jsl $E10000 MEND; from m16.Event MACRO&lab _GetNextEvent&lab ldx #$0A06     jsl $E10000 MEND; from M16.IntMath MACRO&lab _UDivide&lab ldx #$0B0B     jsl $E10000 MEND; from m16.QuickDraw MACRO&lab _GetMasterSCB&lab ldx #$1704     jsl $E10000 MEND MACRO&lab _SetPenState&lab ldx #$2A04     jsl $E10000 MEND MACRO&lab _GetPenState&lab ldx #$2B04     jsl $E10000 MEND MACRO&lab _SetPenSize&lab ldx #$2C04     jsl $E10000 MEND MACRO&lab _SetPenMode&lab ldx #$2E04     jsl $E10000 MEND MACRO&lab _SetPenPat&lab ldx #$3004     jsl $E10000 MEND MACRO&lab _SetSolidPenPat&lab ldx #$3704     jsl $E10000 MEND MACRO&lab _InsetRect&lab ldx #$4C04     jsl $E10000 MEND MACRO&lab _PtInRect&lab ldx #$4F04     jsl $E10000 MEND MACRO&lab _FrameRect&lab ldx #$5304     jsl $E10000 MEND MACRO&lab _PaintRect&lab ldx #$5404     jsl $E10000 MEND MACRO&lab _EraseRect&lab ldx #$5504     jsl $E10000 MEND MACRO&lab _GlobalToLocal&lab ldx #$8504     jsl $E10000 MEND; from M16.Util;............................................................;;        Push long (4 bytes) onto stack;;    pushlong address             - push contents of address;    pushlong address,x           - push contents of address,x;    pushlong const,s             - push contents of stack+const    ;    pushlong #address/const      - push address or constant;    pushlong [zeropage],offset   - push using indirect address;...............................................................	MACRO	pushlong &addr,&offset	IF &addr[1:1]='#' THEN		pea		&addr[2:255]>>16		pea		|&addr[2:255]	ELSEIF &addr[1:1]='[' THEN		ldy		#&offset+2		pushword &addr,y		ldy		#&offset		pushword &addr,y	ELSEIF &offset='s' THEN		pushword &addr+2,s		pushword &addr+2,s	ELSEIF &offset='' THEN		pushword  &addr+2		pushword  &addr	ELSE		pushword &addr+2,&offset		pushword &addr,&offset	ENDIF	MEND;...............................................................;;        Push 2 bytes onto stack;;    pushword loc     -- pushes bytes onto stack from 'loc';    pushword loc,x   -- pushes bytes onto stack from 'loc,x';    pushword #n      -- pushes constant #n onto stack;    pushword         -- pushes bytes onto stack (from A);...............................................................	MACRO	pushword &addr,&reg	IF &addr[1:1]='#' AND &SETTING('LONGA')='ON' THEN		pea		|&addr[2:255]	ELSE		IF &addr­'' THEN			IF &reg­'' THEN 				lda		&addr,&reg			ELSE				lda		&addr			ENDIF		ENDIF		pha	ENDIF	MEND;...............................................................;;        Pull 2 bytes from stack;;    pullword loc     -- pulls bytes off stack and stores in 'loc';    pullword loc,x   -- pulls bytes off stack and stores in 'loc,x';    pullword         -- pulls bytes off stack and leaves in A;...............................................................	MACRO	pullword &addr,&reg		pla	IF &addr­'' THEN		IF &reg­'' THEN			sta		&addr,&reg		ELSE			sta		&addr		ENDIF	ELSEIF &reg­'' THEN 		AERROR 'Illegal 2nd parameter'	ENDIF	MEND; from M16.Window MACRO&lab _InvalRect&lab ldx #$3A0E     jsl $E10000 MEND** my own custom macros*; cmps - signed comparison;		use just like the cmp instruction, but destroys contents of accumulator;		conditions c and z flags just like the built in cmp instruction.; MACRO	cmps	&oprnd					; signed comparison	sec	sbc		&oprnd	beq		@1	bvs		@2 if &Setting('LONGA')='OFF' then	; must determine correct operand size 	eor		#$80 else	eor		#$8000 endif@2	bmi		@greaterThan	clc	dc.b	$B0						; BCS opcode@greaterThan	sec@1	ENDM