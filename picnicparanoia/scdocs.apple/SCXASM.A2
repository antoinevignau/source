S-C Macro Cross AssemblersThe high cost of dedicated microprocessor development systems hasforced many technical people to look for alternate methods to developprograms for the various popular microprocessors. Combining theversatile Apple II with the S-C Macro Assembler provides a costeffective and powerful development system.The S-C Macro Cross Assemblers are identical to the S-C MacroAssembler, except for the language assembled.  They are sold asupgrade packages to the S-C Macro Assembler.  The S-C Macro Assemblercosts $80; once you have it, each Cross Assembler costs only $32.50.  +--------+ +--------+ +--------+ +--------+  |  6502  | |  6800  | |  6809  | |  Z-80  |  |   $80  | | $32.50 | | $32.50 | | $32.50 |  |        | +--------+ +--------+ +--------+  |        +------------------------------------......  |      S-C Macro Assembler Version 1.0  +---------------------------------------------......The S-C Macro Assembler runs in an Apple II computer and assemblesprograms for the 6502 microcomputer plus Steve Wozniak's SWEET-16interpretive language.  There are currently three Cross Assemblersavailable; these also run in the Apple II computer, but assembleprograms for different microcomputers:    Version     Microcomputers    -------     --------------    6800        Motorola 6800, 6801, and 6802    6809        Motorola 6809    Z-80        Zilog Z-80Since the assembly language for each microcomputer is unique, youshould use the appropriate reference books in place of chapters 8 and9 of the S-C Macro Assembler Reference Manual.Each Cross Assembler diskette contains two complete ready-to-runassemblers: one is for execution in the mother-board RAM; the otherone executes in a 16K RAM Card. The HELLO program offers menuselection to load the version you desire.  The diskette also containsone or more test files, which shows examples of every opcode andevery address mode.------------------------------------------------------------------------------------------------------------------------------------------Motorola 6809 VersionThe S-C Macro 6809 Cross Assembler is a complete macro assembler withco-resident program editor.  It is written in 6502 assembly languagefor execution in the Apple II.  It assembles standard 6809 mnemonics,as given in Leventhal (2).The assembled object code may be directed either to Apple memory orto a DOS 3.3 Binary file.  If you have an EPROM burner, the data canbe burned into EPROMS.Differences between 6502 and 6809 Versions:1.  Register names are reserved, and cannot be used as labels.  Theregister names are A, B, D, S, U, X, Y, PC, PCR, DP, and CC.2.  Direct and Extended are the default operand modes.  If theoperand is on the current direct page, the assembler uses directaddressing.  Use "<expression" to force direct mode, and">expression" to force extended mode.3.  The new .DP directive informs the assembler what page should bethe current direct page in a range of code.    .DP $1F         SET DIRECT PAGE    LDA $1FFF       ASSUMED DIRECT PAGE    LDA $3FFF       ASSUMED EXTENDED    LDA <$FF        FORCED DIRECT PAGE    LDA >$1FFF      FORCED EXTENDED4.  Other address modes:    #expression             Immediate    expression,reg          Indexed, not indirect    expression,PCR          PC relative    (expression,register)   Indirect and IndexedUse + or ++ after the register name to indicate auto increment; - or-- for auto decrement.5.  The MGO command assumes you have a Stellation MILL board inslot 5.  MGO starts the 6809 on the MILL and puts the 6502 in anidle loop, as described in the Stellation documentation:    *   Disable on-board ROM.    *   Set memory re-mapping.    *   Clear all interrupts.    *   Set 6809 reset vector at $FFFE-F        ($7FFE-F to the 6502) to the remapped MGO value.    *   Start 6809 from reset state.---------------------------------------------------------------------Keyboard input is made available at P.KEY, display output is obtainedat P.OUT.  6809 execution is terminated when control-B is typed orwhen a non-zero value is found at P.FLAG                6502        6809    P.FLAG      $50         $8050    P.KEY       $51         $8051    P.OUT       $52         $8052References:1.  6809 Programming for Logic Design, Adam Osborne,OSBORNE/McGraw-Hill.2.  6809 Assembly Language Prograinming, Lance Leventhal,OSBORNE/McGraw-Hill, 1981. $16.99.3.  6809 Microcomputer Programming & Interfacing with Experiments,Andrew C. Staugaard, Jr., Howard W. Sams & Co., 1981, 270 pages,$13.95.4.  The MC6809 Cookbook, Carl D. Warren, Tab Books, 1981. 176 pages,$6.95.------------------------------------------------------------------------------------------------------------------------------------------Zilog Z-80 VersionThe S-C Macro Z-80 Cross Assembler is a complete macro assembler withco-resident program editor.  It is written in 6502 assembly languagefor execution in the Apple II.  It assembles standard Z-80 mnemonics,as given in Leventhal (2).The assembled object code may be directed either to Apple memory orto a DOS 3.3 Binary file.  If you have an EPROM burner, the data canbe burned into EPROMs.Differences between 6502 and Z-80 Versions:1.  Hexadecimal numbers can be handled in two ways: standard Z-80 andstandard 6502 notation.  Standard Z-80 notation adds an 'H' to the endof the number.  The number must start with a decimal digit (so if thevalue starts with A through F, put a 0 in front of it).  Standard6502 notation precedes hex numbers with a dollar sign ($).  Forexample:        0H  =  $0      531H  =  $531    0FFFFH  =  $FFFF    0C030H  =  $C030In this documentation, the H-form will be used to show a Z-80 mappedaddress; the $-form will be used for 6502 mapped addresses.2.  There may be any number of spaces between the opcode and theaddress.  If there are two operands in the address field (as in theLD and BIT opcodes), the operands must be separated by commas.  Thetab stop for the address field has been moved to the right onecolumn, to accomodate four character opcodes.The RET and IM opcodes are special cases.  They each have a formwhich require no operand, as well as a form which require an operand.RET may be either a conditional or an unconditional return.  If it isunconditional, there must be either nothing after the opcode or atleast three spaces before the comment field.  If there are less thantwo spaces after the opcode, it will be interpreted as a conditionalreturn.  This should be no problem if the tab stops are used.The IM opcode takes three forms: IM0, IM1, and 1M2.  There must be nospace between the IM and the number, and a label cannot besubstituted for the number.  This differs slightly from the Leventhalbook, where there is a space between IM and the number.---------------------------------------------------------------------3.  Register names and conditions cannot be used as labels.  An errorwill result if this is attempted.  The reserved names are:     8-bit Registers:  A, B, C, D, E, H, L, I, and R    16-bit Registers:  IX, IY, and SP      Register pairs:  BC, DE, SP, HL, and AF          Conditions:  NZ, Z, NC, C, PO, PE, P, and M4.  The z-80 Cross Assembler will turn on a Microsoft Softcard whenthe MGO command is executed.  (MGO works equally well with other Z-80cards such as that of Applied Engineering.)  The default slot is 5,but that can be changed (see section on parameters, below).  When anMGO is executed, a short Z-80 routine is installed at location OH($1000 in 6502 address space).  This routine is as follows:    START   LD   SP,0FFFFH      INITIALIZE STACK POINTER            CALL xxxx           xxxx IS FILLED IN BY MGO ROUTINE            LD   (0EX00H),A     TURN OFF SOFTCARD, x IS SLOT NUMBER            JR   START          WHEN CARD TURNED BACK ON, JUMP BACKThe Softcard is turned on and the 6502 off when the 6502 programwrites to location $Cx00 (x is the slot number).  When the Z-80program writes into 0EX00H, the Z-80 is halted and the 6502 isrestarted, continuing where it previously stopped.  The processorscan continue to toggle back-and-forth in this manner.A small 6502 driver routine can be written to handle such things asinput or output while the Z-80 does most of the processing.  That iswhat is done in Microsoft's version of CP/M.If the Apple RESET key is pressed, the Z-80 will reset, setting theZ-80 PC-register to 0H.  If you intend to use MGO and are not surewhether the Z-80 PC-register is properly set, be sure to press RESET.If RESET is not pushed after Softcard use, the Z-80 will continuewherever the PC-register points.  That is the reason for the JR STARTinstruction above.The Softcard remaps the address space of the Apple.  This providescontiguous memory from 0000H to 0DFFFH (with a 16K RAM Cardinstalled) without accessing 6502 page 0, stack, or screen memory.This is explained in the Softcard manuals, but it is presented againhere.      Z-80 Address          Apple Address    00000H - 0AFFFH         $1000 - $BFFF    0B000H - 0DFFFH         $D000 - $FFFF    0E000H - 0EFFFH         $C000 - $CFFF    0F000H - 0FFFFH         $0000 - $0FFF---------------------------------------------------------------------5.  The .OR, .TA and .TF directives are slightly different in the Z-80version, due to the memory address remapping..OR (ORigin) sets the assembly origin to Z-80 address space, that is,where the Z-80 thinks it is.  .TA (Target Address) specifies a6502-mapped address where the object code will be written.  .TF(Target File) will set the binary load address to the current targetaddress.If an origin is used without a target address, the target defaults tothe origin.  If no .OR or .TA are included in the source file, theassembler defaults to origin 0F800H, target address $800.6.  The Z-80 reset vector is at 0H, or $1000.  This just happens tocoincide with the start of the 6502 version of the S-C MacroAssembler.  To make room for the MGO linkage routine, the assemblerhas been moved up 11 bytes and now starts at $100B.  Because of this,you should add 11 ($0B) to all of the addresses in Appendix D(CUSTOMIZING).  There is also one additional parameter, the slotnumber of the Z-80 card.The 16K RAM Card version of the Z-80 Cross Assembler has not beenmoved up, but the symbol table start has.  It now starts at $1100rather than $1000.Here are the new customization parameter addresses:    Normal  16K Card    $100B   $D000       Hard Entry Point.    $1011   $D006       USR Vector.    $1014   $D009       PRT Vector.    $1017   $D00C       .US Directive Vector.    $101A   $D00F       Tab Control Character.    $101B-F $D010-4     Tab Column Settings.    $1020   $D015       Escape-L Comment Character.    $1021   $D016       Lower-Case Mod Flag.    $1022   $D017       Compression Flag.    $1023   $D018       Search String Wildcard Character.    $1024   $D019       Softcard Slot Number.                        Normally $C5, set to slot number plus $C0.    $1025   $D01A       Character Output Vector.    $1028   $D01D       Always $A9.    $1029   $D01E       Symbol Table starting page number.References:1.  Z-80 Programming for Logic Design, Adam Osborne,OSBORNE/McGraw-Hill.2.  Z-80 Assembly Language Programming, Lance Leventhal,OSBORNE/McGraw-Hill, 1979, $16.99.3.  TRS-80 Assembly-Language Programming, William Barden, Jr., RadioShack, 1979, 224 pages, $3.95.------------------------------------------------------------------------------------------------------------------------------------------Motorola 68000 VersionThe S-C 68000 Macro Cross Assembler is a complete macro assemblerwith co-resident program editor.  It is written in 6502 assemblylanguage for execution in the Apple II.  It assembles standardMotorola 68000 mnemonics, using the same assembler syntax asdescribed in the Motorola reference manual.Differences between 6502 and 68000 Versions:1.  All operand expressions have been expanded to 32 bits. This is toallow for the 16-megabyte address range of the 68000, and for 32-bitconstants.  A single 32-bit number will represent values between 0and 4,294,967,295.  Although addresses are only 24 bits, theassembler will accept an address of 32 bits without an error.  Futureversions of the 68000 microprocessor will probably be able to use thefull 32-bit address.2.  The .BS (block storage) directive will only accept values up to65535.3.  The syntax of the .DA directive has been slightly changed, toallow 32-bit data.  If a # precedes the value, it is treated as an8-bit value.  If a / precedes it, it is a 16-bit value. If nothingappears before the value, it is 32 bits.  You may isolate any 8-bitor 16-bit field within a 32-bit value using the leading "#" or "/",together with division by the appropriate constant.  If you want, forexample, the third byte of a number as data, you could use either".DA #value/256" or ".DA #value/$l00".  Similarly, the high-order 16bits of a number could be obtained by either ".DA /value/65536" or".DA /value/$10000".4.  The origin (.OR) of a program may be set to any value from $0through $FFFFFFFF.  However, if you are assembling to memory, youmust specify a target address (.TA) somewhere in the Apple's memoryrange.  If you use a target file (.TF), the DOS BLOAD address will bethe same as the low order 16 bits of the origin.  (If you want toload it elsewhere, specify the Address parameter with your BLOADcommand: BLOAD FILE,A$address.)5.  The MGO command is unchanged.  It will begin execution of a6502 program.  If you have a 68000 board in your Apple, you mayimplement the USR command to begin execution of 68000 programs.---------------------------------------------------------------------Source Code Syntax:The opcode and register mnemonics used are taken fromMotorola's MC68000 16-Bit Microprocessor User's Manual, thirdedition, and Osborne/McGraw-Hill's 68000 Assembly LanguageProgramming by Gerry Kane, Doug Hawkins, and Lance Leventhal.There are a few minor changes from the Leventhal book, however.1.  Many opcodes allow an extension specifying the length(either byte, word, or long).  If no length is specified, adefault of word is assumed.  This extension consists of aperiod immediately following the opcode (NO SPACES here) and aletter 'B', 'W', 'L', or 'S'.  (The 'S' is for short branches.)The opcodes that allow an extension are: ADD, ADDA, ADDQ, ADDI, ADDX,AND, ANDI, ASL register, ASR register, CLR, CMP, CMPI, CMPI, CMPM,EOR, EORI, EXT, LSL register, LSR register, MOVE, MOVEA, MOVEM,MOVEP, NEG, NEGX, NOT, OR, ORI, ROL register, ROR register, ROXLregister, ROXR register, SUB, SUBA, SUBQ, SUBI, SUBX, TST, and therelative branches, discussed later.  All other opcodes may not havean extension. Note that ANDI, EORI, MOVE, and ORI, when used with theregisters CCR, SR, or USP, do not need an extension.2.  The addressing modes and assembler syntax are shown below. An orDn specify a register (where n is a digit 0-7), num represents anumber, label, or expression~ and d is a displacement.    Dn              Data reg direct    An              Addr reg direct    (An)            Addr reg indirect    (An)+           Addr reg indirect with post-increment    -(An)           Addr reg indirect with pre-decrement    d(An)           Addr reg md with displacement    d(An,An) or    d(An,Dn)        Addr reg md with index and displacement    num or <num     Absolute short (see paragraph 5.)    num or >num     Absolute long (see paragraph 5.)    d(PC)           Program counter relative with displacement    d(PC,An) or     d(PC,Dn)        PC relative with index and displacement    #num            Immediate3.  In the Indexed modes the index register (the second register) mayhave a .W or .L appended to it.  This specifies the size of theregister.  See the Leventhal book, p. 3-22 for more details.4.  Unlike the Leventhal book, the program counter relative modesMUST have PC as the first register.  The book says that itmay beomitted in the indexed form i.e. d(An) instead of d(PC,An).  Thiswill not work!  The PC is necessary for the assembler to distinguishthis mode from the d(An) form.---------------------------------------------------------------------5.  For the Absolute addressing modes, either 16 or 32 bits may beforced using the < and >, respectively.  No range checking is usedhere.  If neither is present, the assembler must decide which to use.If the expression is defined at the time it is encountered (not aforward reference), the 16-bit mode is used if the value is less than$8000 (not between $8000 and $FFFF because the address issign-extended), and 32-bit mode otherwise.  If the expression doesinvolve a forward reference, the default is the 16-bit mode.  If itis not less than $8000 when forward references are resolved, a RANGEERROR is generated.6.  Relative branch sizes are indicated with ".S" or ".L" suffix.  A".S" after the opcode forces a short (8-bit) displacement.  A ".L"forces a long (16-bit) displacement.  If neither is present and theexpression is defined, either 8- or 16-bit is used, as needed.However, if it is a forward reference, 16-bit is assumed.  You mustuse a .S if you want a short branch on a forward reference.  Notethat only BRA, BSR, and Bcc (conditional branch) use this.  DBccalways uses a 16-bit displacement.7.  There may be as many spaces as you want between the opcode andthe address field.  However, there may not be any spaces in theaddress field.  If there are two operands, they must be separated bya comma.8.  A label may not be the same as one of the register names. Thereserved labels are: D0, D1, D2, D3, D4, D5, D6, D7, A0, A1, A2, A3,A4, AS, A6, A7, CCR, SR, USP, and PC.9.  The conditions for use with Bcc, DBcc, and Scc are:    HI      high    LS      low or same    CC      carry clear    Cs      carry set    HS      high or same (same as CC)    LO      low (same as CS)    NE      not equal    EQ      equal    VC      overflow clear    VS      overflow set    PL      plus    MI      minus    GE      greater or equal    LT      less than    GT      greater than    LE      less or equalIn addition, the following may also be used with DBcc and Scc:    T       true    F       false    RA      same as false, used for DBRA.---------------------------------------------------------------------10.  Although some instructions, like ADD, have different forms (i.e.ADD, ADDA, ADDQ, ADDI), you don't always have to specify the A, Q, orI at the end.  For example, if you have the instruction "ADD D1,A5",the assembler converts that to ADDA D1,A5.  This works for ADD, AND,CMP, EOR, MOVE (only to MOVEA, not MOVEQ), OR, and SUB.If the instruction has a Quick Immediate form (ADDQ, SUBQ), theassembler will automatically use that form if the operand isimmediate and the range is from 1-8.  If it is out of range, theregular Immediate form is used.  The immediate form can be forced byusing ADDI, SUBI, etc., but the Quick mode can not be used if thedata is out of range.When in doubt, use the I, Q, A, or whatever at the end.  NOTE: ABCD,ADDX, MOVEP, MOVEM, MOVEQ, SBCD, and SUBX must have the Q, X, orwhatever on the end.11.  All 68000 instructions must start on a word boundary (i.e. aneven numbered address).  If the instruction does not, the assemblerwill give an error.  This is most likely to occur after a data areathat has byte-long data.  Note that byte data can be anywhere, butword and long word data must also start on a word boundary.  This isnot checked for by the assembler.  If you get this error, check thepreceding lines.  There will probably be a data area there.  Just puta .BS 1 or .DA #0 after the byte data to force the program counterback to an even number.------------------------------------------------------------------------------------------------------------------------------------------S-C Software Corporation2331 Gus Thomasson, Suite 125, P.O. Box 280300, Dallas, Texas 75228(214) 324-2050Patches to the 68000 Cross Assembler...,......March 23, 1983Thanks to the persistent efforts of John Wallace and Lane Hauck(Cross Assembler users in Wisconsin and California, respectively), wehave discovered several problems in the S-C 68000 Cross Assembler.The problems have to do with the PC-relative addressing mode, forwardreferences, ard origins above $FFFF.The patches below will fix all the known problems, but they must bevery carefully applied.  We recommend that you make the patches to aCOPY of the orginal disk, just in case of an accident.  The patchesshould apply to all disk with serial numbers from 1 to 55.If the patches appear too difficult, too much trouble, or whatever,we can update your original disk.  Just send it to us with $2 for ourreturn postage.  We will copy the new version onto it and send itback to you.  It will be exactly the same as if you typed in thesepatches, but your fingers will feel better!Clarifications, etc.:1.  PC-relative Addressing ModeThe 68000 Cross Assembler assumes that the d-expression in "d(PC)"or "d(PC,reg)" is an actual address.  The assembler subtracts thecurrent value of the program counter from your expression to get thedisplacement.Therefore, do NOT write "ADD TABLE-*(PC),D3"; instead, write"ADD TABLE(PC),D3".2.  Page Zero Usage by the AssemblerUnlike the 6502 Macro Assembler, the 68000 Cross Assembler does useseveral page zero locations between $00 and $1E during assembly.  Ifyou wish to assemble code to these locations, use some other targetaddress (.TA directive) and move the object code down after assembly.---------------------------------------------------------------------3.  Address Size in Absolute ModeEither 16- or 32-bit addresses may be forced by prefixing the addressexpression with "<" or ">", respectively.  If neither is present,the assembler must decide which to use.If you do not specify which length address to use, the assemblertries to select the most reasonable size.  There are three factorsused in deciding which size to use: the current assembly address(program counter), whether the address expression involves a forwardreference, and the actual value of the address expression.If the address expression is defined at the time it is encountered(not a forward reference) and has a value in the range$000000-$007FFF or $FF8000-$FFFFFF, the assembler will use the 16-bitmode.If the address expression does involve a forward reference, but theprogram counter is in the range for a 16-bit address, the 16-bit modeis used.  If the address expression value is not in range afterforward references are resolved, a RANGE ERROR is generated.  Toassemble under the latter conditions, use the ">" prefix to force32-bit mode.4.  Sign Extension on 16-bit AddressesMotorola made a design decision when they implemented the short16-bit direct addressing mode (in the opinion of some, they made thewrong choice): they opted to sign-extend the address to 32 bits.This effective1y splits the "zero page" into two parts: 32K bytesfrom $000000 to $007FFF, and another 32K bytes from $FF8000 to$FFFFFF.Digital Acoustics, makers of the Dtack-Grounded co-processor board,are among those who dispute the wisdom of Motorola's choice.  Intheir system the highest 32K bytes of memory are mapped into therange from $008000 to $00FFFF, giving an effective contiguous 64Kbyte "zero paqe ".If you want the assembler to work this way too, making references to$8000-$FFFF into 16-bit addresses and those to $FF8000-$FFFFFF into32-bit addresses, you can apply some additional patches listed below.Files containing both versions are included on the new release disk(they will be written on your disk if you send it to us).---------------------------------------------------------------------Patches to Correct Problems:The patches 'nay be made to both the motherboard version (which loadsat A$1000), and to the language card (RAM Card) version (which loadsat A$D000).  The numbers in parentheses show the previous contents ofmodified locations.1.  A$1000 Version:     ]BRUN S-C.ASM.MACRO.68000  (or select from boot menu)    :$24D9:43                   (46)    :$251F:4C 64 3D             (60 A4 7E)    :$2920:F3                   (7E)    :$2922:3B                   (23)    :$2745:72 3D                (B5 24)    :$233D:20 78 3D D0 3A EA    (A5 5E C5 CE A5 5F)    :$308E:81 3D                (C2 1F)    :$2818:4C 91 3D             (20 68 12)    :$2836:D9 3D                (0F 23)    :$2842:4C E1 3D EA          (A2 39 A0 04)    :$1F20:20 8A 3D EA          (85 A2 85 5F)    :$3D64:10 0B A9 00 85 99 85 9A 85 9B 85 9C 98 60    :$3D72:20 B5 24 84 F3 60    :$3D78:A5 5E C5 CE A5 5F A4 71 60    :$3D81:A5 9B 05 9C 85 71 4C C2 1F    :$3D8A:85 A2 85 5F 86 71 60    :$3D91:20 68 12 A6 A3 8A 05 A4 D0 07 24 A2 30 0C 4C 1B 28    E8 D0 06 24 A2    :$3DA7:10 02 30 F4 A9 08 85 AA A2 39 A0 04 A5 7E 30 1F A5    60 F0 04 A5 E2    :$3DBD:F0 17 A5 9C 05 9B D0 04 A5 9A 10 05 20 F0 3D B0 08    A2 38 A0 02 A9 10    :$3DD4:85 AA 4C 4A 28    :$3DD9:20 F0 3D 90 F8 4C 0F 23    :$3DE1:20 F0 3D B0 03 4C 4A 28 A2 39 A0 04 4C 46 28    :$3DF0:A5 9B C9 FF D0 06 24 9A 10 02 18 60 38 60The following patch was sent out earlier.  In case you didn'treceive it, here it is again:    :$3B31:98                   (99)Now save the corrected assembler:    :BSAVE S-C.ASM.MACRO.68000,A$1000,L$2DFENow use the following program to check your work:    :$300:A2 9A A9 00 18 7D 63 3D CA D0 F9 4C DA FD     :$300GIf the number printed is 47, you probably entered the patches at theend correctly.  If it isn't, however, you should recheck all the codefrom $3064 to $3DFE.---------------------------------------------------------------------2.  A$D000 Version:    ]EXEC LOAD LCASM 68000      (or select from boot menu)    :$C083 C083                 (enable the language card)    :$E610:43                   (46)    :$E656:4C 2C F7             (60 A4 7E)    :$EA57:F3                   (7E)    :$EA59:3B                   (23)    :$E87C:3A F7                (EC E5)    :$E474:20 40 F7 D0 3A EA    (A5 5E C5 CE A5 5F)    :$F1C5:49 F7                (F9 E0)    :$E94F:4C 59 F7             (20 A0 F6)    :$E96D:A1 F7                (46 E4)    :$E979:4C A9 F7 EA          (A2 39 A0 04)    :$E057:20 52 F7 EA          (85 A2 85 5F)    :$F72C:10 0B A9 00 85 99 85 9A 85 9B 85 9C 98 60    :$F73A:20 EC E5 84 F3 60    :$F740:A5 5E C5 CE A5 5F A4 71 60    :$F749:A5 9B 05 9C 85 71 4C F9 E0    :$F752:85 A2 85 5F 86 71 60    :$F759:20 A0 F6 A6 A3 8A 05 A4 D0 07 24 A2 30 0C 4C 52 E9    E8 D0 06 24 A2    :$F76F:10 02 30 F4 A9 08 85 AA A2 39 A0 04 A5 7E 30 1F A5    60 F0 04 A5 E2    :$F785:F0 17 A5 9C 05 9B D0 04 A5 9A 10 05 20 B8 F7 B0 08    A2 38 A0 02 A9 10    :$F79C:85 AA 4C 81 E9    :$F7A1:20 B8 F7 90 F8 4C 46 EA    :$F7A9:20 B8 F7 B0 03 4C 81 E9 A2 39 A0 04 4C 7D E9    :$F7B8:A5 9B C9 FF D0 06 24 9A 10 02 18 60 38 60The following patch was Bent out earlier.  In case you didn't receiveit, here it is again:    :$D7AF:98                   (99)Now save the corrected assembler    :BSAVE S-C.ASM.MACRO.68000.LC,A$D000,L$27C6Now use this program to check your work:    :$300:A2 9A A9 00 18 7D 2B F7 CA D0 F9 4C DA FD    :$300GYou should get B1 as your answer.  If you didn't, you probably have atyping error in the patches at the end. ($F72C to $F7C3)---------------------------------------------------------------------Patches for Dtack-Grounded Mapping:The following patches are optional.  See section 4 above for explanation.1.  A$l000 Version:    ]BRUN S-C.ASM.MACRO.68000   (or enter from boot menu)    :$2831:F0 17    :$2836:0F 23    :$283E:F0 0A    :$2842:A2 39 A0 04    :$3D9A:10    :$3D9E:00    :$3DC4:10 F0 07    :$BSAVE S-C.ASM.MACRO.68000,A$1000,L$2DFE    2.  A$D000 Version:    ]EXEC LOAD LCASM 68000    (or select from boot menu)    :$C083 C083    :$E968:F0 17    :$E96D:46 E4    :$E975:F0 0A    :$E979:A2 39 A0 04      :$F762:10    :$F766:00    :$F78C:10 F0 07    :$BSAVE S-C.ASM.MACRO.68000.LC,A$D000,L$27C6We hope you are continuing to enjoy using the S-C Assemblers, andapologize for any inconvenience these patches may have caused.---------------------------------------------------------------------