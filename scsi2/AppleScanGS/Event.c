/************************************************************************ Event.c** Copyright (c)* Apple Computer, Inc.  1986-1989* All Rights Reserved.** This file contains the code which implements the * main event loop used by the scanner program.***********************************************************************/#include <types.h>#include <locator.h>#include <quickdraw.h>#include <event.h>#include <menu.h>#include <window.h>#include "Scan.h"extern WmTaskRec        event;extern unsigned int     quitFlag;extern GrafPortPtr	previewWindowPtr;extern GrafPortPtr	settingsWindowPtr;static GrafPortPtr  lastWindow;         /* This private global is used in checkFrontW()                                        ** to prevent extra work when the windows                                        ** have not changed.  It is initialized                                        ** at the beginning of mainEvent().                                        *//************************************************************************ doSetPageScroll** This procedure is called when an inGrow or inZoom message is returned* by TaskMaster.** This procedure resets the values used to scroll the content region* when the page areas are clicked on in the scroll bars.************************************************************************/static void doSetPageScroll(){	int		tempH, tempV;		tempV = lastWindow->portRect.v2-lastWindow->portRect.v1;	/* calculate vertical size */	tempH = lastWindow->portRect.h2-lastWindow->portRect.h1;	/* calculate width */	SetPage(tempH-10, tempV-10, lastWindow);}/************************************************************************ doControls** This procedure is called when an inControl message is returned* by TaskMaster.** When this routine gets control, the ID of the control that was* hit is in TaskDATA4.  The control handle is in TaskData2 and* the part code is in taskData 3.***********************************************************************/void    doControls(){    LongWord    theID, thePartCode;	LongWord	theControlHandle;	    theID = event.wmTaskData4;	thePartCode = event.wmTaskData3;	theControlHandle = event.wmTaskData2;	if (( 0 <= theID) && (theID <= 0xFFFFFFFF )) {		    	switch(theID) {			case	ScanButton:										doScanButton();						break;			case	PreviewButton:									doPreviewButton();						break;		}    }}/************************************************************************ doInContent** This procedure is called when an InContent message is returned* by TaskMaster.** When this routine gets control, the ID of the control that was* hit is in TaskDATA4.  The control handle is in TaskData2 and* the part code is in taskData 3.***********************************************************************/void    doInContent(){    LongWord    theID, thePartCode;	LongWord	theControlHandle;		    theID = event.wmTaskData4;	thePartCode = event.wmTaskData3;	theControlHandle = event.wmTaskData2;		SelectWindow(event.wmTaskData);	#if 0	if (event.what == 0x01) {						/* was it a mouse down event? */		if ((GrafPortPtr) event.wmTaskData == previewWindowPtr){			doInPreview(event.where); 		}    }#endif}/************************************************************************ checkFrontW** This routine checks the front window to see if any changes need* to be made to the menu items.** We do this so that the edit items are only active when a desk* accessory is active.***********************************************************************/void    checkFrontW(){    GrafPortPtr     theWindow;	extern int		cTable[], defCTable[];    theWindow = FrontWindow();        /* Get the front window into local storage.*/        if (theWindow == lastWindow) return;        /* If the lastWindow is this window, we are all set. */        /* If there are no windows, everything should be disabled */    if (!theWindow) {        SetMenuFlag(0x0080, EditMenuID);        HiliteMenu(0,EditMenuID);		SetColorTable(0,defCTable);    }	/* if the front window is an image window, then we want to enable the edit items */    if (!( (theWindow == previewWindowPtr)||(theWindow == settingsWindowPtr))) {		EnableMItem(SaveAsID);	/* allow Save As... */		SetMenuFlag (0xFF7F, EditMenuID);       /* Set up for da windows. */		HiliteMenu(0,EditMenuID);	} else {		DisableMItem(SaveAsID);					/* don't allow saving */        /* Otherwise we look at the window and see what to do. */        if (GetSysWFlag(theWindow)) {             SetMenuFlag (0xFF7F, EditMenuID);       /* Set up for da windows. */         	HiliteMenu(0,EditMenuID);        } else {            SetMenuFlag (0x0080, EditMenuID);       /* Set up for our windows. */         	HiliteMenu(0,EditMenuID);        }    }	/* use grayscale pallette for Preview or Image windows */	if((theWindow != settingsWindowPtr) && !GetSysWFlag(theWindow))		SetColorTable(0,cTable);	else		SetColorTable(0,defCTable);    lastWindow = theWindow;     /* Remember this for next time. */		/* here we want to update the hor/vert text if need be */}/************************************************************************ mainEvent** This is the main part of the program.  The program cycles in this* loop until the user choose select.***********************************************************************/void    mainEvent(){    unsigned int    code;	unsigned		temp;    event.wmTaskMask = 0x001FFF7F;          /* Allow TaskMaster to do everything, and return inContents   */    quitFlag         = 0;                   /* Done flag will be set by Quit item.  */    lastWindow       = NULL;                /* Init this for checkFrontW().         */    for (;;) {        checkFrontW();        code = TaskMaster(0xFFFF, &event);        switch(code) {			case wNoHit:	/* null event, but TaskMaster might have handled something */				temp = event.wmTaskData & 0xffff;	/* get the event code */				if(temp == wInGrow || temp == wInZoom)	/* if the window changed sizes */					doSetPageScroll();				break;            case wInGoAway:                doCloseTop();                break;            case wInSpecial:            case wInMenuBar:                doMenu();                break;            case wInControl:                doControls();                break;			case wInContent:				doInContent();				break;        }        if (quitFlag) break;    }}