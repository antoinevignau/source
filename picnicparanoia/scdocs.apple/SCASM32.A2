S-C ASSEMBLER IIDisk Version 3.2for theAPPLE II ComputerCopyright 1979S-C SOFTWA REP.O. Box 280300Dallas, Texas 75228(214) 324-2050---------------------------------------------------------------------TABLE OF CONTENTS1.0 Introduction and Feature List . . . . . . . . . . .   12.0  Commands  . . . . . . . . . . . . . . . . . . . . .  32.1  Assembler Commands  . . . . . . . . . . . . . . . .  32.1.1  Editing Commands  . . . . . . . . . . . . . . . .  42.1.1.1  NEW Command   . . . . . . . . . . . . . . . . .  42.1.1.2  RENUMBER Command  . . . . . . . . . . . . . . .  42.1.1.3  DELETE Command  . . . . . . . . . . . . . . . .  42.1.1.4  LIST Command  . . . . . . . . . . . . . . . . .  42.1.1.5  FIND Command  . . . . . . . . . . . . . . . . .  52.1.1.6  Screen Editing  . . . . . . . . . . . . . . . .  52.1.2  Listing Control Commands  . . . . . . . . . . . .  62.1.2.1  FAST Command  . . . . . . . . . . . . . . . . .  62.1.2.2  SLOW Command  . . . . . . . . . . . . . . . . .  62.1.2.3  PRT Command . . . . . . . . . . . . . . . . . .  62.1.3  Object Commands . . . . . . . . . . . . . . . . .  72.1.3.1  ASM Command . . . . . . . . . . . . . . . . . .  72.1.3.2  MGO Command . . . . . . . . . . . . . . . . . .  72.1.4  Tape Commands . . . . . . . . . . . . . . . . . .  82.1.4.1  LOAD Command  . . . . . . . . . . . . . . . . .  82.1.4.2  SAVE Command  . . . . . . . . . . . . . . . . .  82.1.4.3  JOIN Command  . . . . . . . . . . . . . . . . .  82.2 DOS Commands . . . . . . . . . . . . . . . . . . . .  82.2.1  Housekeeping Commands . . . . . . . . . . . . . .  92.2.2  Source Maintenance Commands . . . . . . . . . . .  92.2.3  Object Maintenance Commands . . . . . . . . . . .  92.2.4  I/O Selection Commands  . . . . . . . . . . . . .  92.2.5  BASIC Commands  . . . . . . . . . . . . . . . . .  92.3  Monitor Commands  . . . . . . . . . . . . . . . . . 103.0  Source Program Format . . . . . . . . . . . . . . . 113.1  Label Field . . . . . . . . . . . . . . . . . . . . 113.2  Opcode Field  . . . . . . . . . . . . . . . . . . . 123.3  Operand Field . . . . . . . . . . . . . . . . . . . 123.4  Comment Field . . . . . . . . . .   . . . . . . . . 123.5  Comment Lines . . . . . . . . . . . . . . . . . . . 123.6  Sample Source Program . . . . . . . . . . . . . . . 134.0  Assembler Directives  . . . . . . . . . . . . . . . 154.1  .OR -- Origin   . . . . . . . . . . . . . . . . . . 154.2  .TA -- Target Address . . . . . . . . . . . . . . . 154.3  .EN -- End of Program . . . . . . . . . . . . . . . 174.4  .EQ -- Equate . . . . . . . . . . . . . . . . . . . 184.5  .DA -- Data . . . . . . . . . . . . . . . . . . . . 184.6  .HS -- Hex String . . . . . . . . . . . . . . . . . 194.7  .AS -- ASCII String . . . . . . . . . . . . . . . . 195.0  Operand Expressions . . . . . . . . . . . . . . . . 215.1  Decimal Numbers . . . . . . . . . . . . . . . . . . 215.2  Hexadecimal Numbers . . . . . . . . . . . . . . . . 215.3  Labels  . . . . . . . . . . . . . . . . . . . . . . 215.4  Asterisk (*)  . . . . . . . . . . . . . . . . . . . 22---------------------------------------------------------------------6.0 Addressing Modes . . . . . . . . . . . . . . . . . . 236.1  Implied Mode  . . . . . . . . . . . . . . . · . . . 256.2  Relative Mode . . . . . . . . . . . . . . . . . . . 256.5  Other Modes . . . . . . . . . . . . . . . . . . . . 256.4  Chart of Other Modes  . . . . . . . . . . . . . . . 267.0  SWEET-16  . . . . . . . . . . . . . . . . . . . . . 277.1  Sample SWEET-16 Program . . . . . . . . . . . . . . 28Appendix . -- Operation and Memory Usage . . . . . . .  A-1A.1  Contents of the Disk  . . . . . . . . . . . . . .  A-1A.2  Copying the Disk  . . . . . . . . . . . . . . . .  A-1A.3  Memory Usage  . . . . . . . . . . . . . . . . . .  A-2A 4  ROM Usage . . . . . . . . . . . . . . . . . . . .  A-2A.5  Description of Sample Source Programs . . . . . .  A-4A.6  Useful Information  . . . . . . . . . . . . . . .  A-4A.7  Handy Patches . . . . . . . . . . . . . . . . . .  A-5Appendix B -- Error Messages . . . . . . . . . . . . .  B-1Appendix C -- Printer Software . . . . . . . . . . . .  C-1C.1 Listing of the PRT Subroutine  . . . . . . . . . .  C-2Appendix D -- Bibliography . . . . . . . . . . . . . .  D-1D.1 Sources of Help for 6502 Programming . . . . . . .  D-1D.2 Sources of Help for SWEET-16 . . . . . . . . . . .  D-2Registration Form---------------------------------------------------------------------INTRODUCTIONS-C ASSEMBLER II is a convenient and powerful tool for softwaredevelcpment on the Apple II Computer.  The assembler uses standard6502 mnemonics and syntax, and includes many useful features forcreating, editing, assembling, and testing your assembly languageprograms.  Now assembly language programming is almost as easy asprograinming in BASIC.Here is a summary of the most exciting features:*   Operates as a subsystem under standard Apple DOS 3.2*   BASIC-like text editing (line numbers, LIST and DELETE commands)*   Full Apple II screen editing*   Tab stops for opcode, operand, and comment fields*   A fast RENUMBER command*   LOAD and SAVE commands to maintain your programs on disk or tape.*   Labels of from 1 to 6 characters*   Arithmetic expressions in operand field (using decimal, hexadecimal    numbers and labels)*   Comments, for built-in documentation*   English-language error messages*   FIND command, to search through source programs*   Ability to assemble standard syntax SWEET-16 opcodes*   All DOS commands usable from within S-C ASSEMBLER II*   All Apple Monitor commands usable from within S-C ASSEMBLER II*   Speed and suspension control over listing and assembly*   Built-in software for controlling the Practical Automation DMTP-6uP    Printer (easily replaceable with software for any other printer)*   Ability to use Apple parallel or serial printer interface cards to    any printer (PR#s command)*   Continuing development and support by S-C SOFTWARE to provide more    useful features and extensions with future releases- 1 -------------------------------------------------------------------------------------------------------------------------------------------COMMANDSThere are three types of commands in S-C ASSEMBLER II:Assembler Commands, DOS Commands, and Monitor Commands. The AssemblerCommands are used to control the editor and assembler.  All of theApple Monitor and DOS Commands are recognized, although they are notall of use from within S-C ASSEMBLER II.  Commands are typedimmediately after the prompt symbol, which is a colon (:).ASSEMBLER COMMANDSThere are thirteen assembler commands in S-C ASSEMBLER II. Allassembler commands may be abbreviated to the first three letters ifyou so desire.ASM                     Assemble source program, put object program                        into memory, and produce assembly listing.DELETE line#            Delete specified line.DELETE line#,line#      Delete line range.FAST                    Select normal listing speed, turn off printer                        software.FIND string             List all lines containing the specified string.JOIN                    Join a program from tape to one already in memory.LIST                    List entire source program.LIST line#              List specified line.LIST line#,line#        List line range.LOAD                    Load source program from tape.MGO expression          Execute object program, starting at address                        specified by value of expression.NEW                     Delete entire source program, start all over.PRT                     Turn on printer software.RENUMBER                Renumber all lines of source program starting                        with 1000, in steps of 10.SAVE                    Save source program on tape.SLOW                    Select slow listing speed, turn off printer                        software.- 3 ----------------------------------------------------------------------The assembler commands can be conveniently grouped into editingcommands, listing control commands, object commands, and tapecommands.Editing CommandsThe editor in S-C ASSEMBLER II combines the powerful Apple screenediting features with a BASIC-like line editor. Source programs areentered and edited in almost exactly the same way you would enter andedit an Integer BASIC program.NEW Command:  Deletes the current source program from memory, andrestarts S-C ASSEMBLER II just as though you re-entered it from themonitor or DOS.RENUMBER Command:  Assigns new line numbers to every line in thecurrent source program.  The first line will receive the number 1000,and subsequent lines will be numbered with an increment of 10.  (SeeAppendix A for instructions for setting a different starting linenumber or increment.)DELETE Command:  Deletes a line or a range of lines from your sourceprogram, just as in BASIC.  Another way to delete a single line is totype its line number followed immediately by a carriage return.(Warning: DELETE followed by a file name is a DOS command, and willdelete a file from your disk.)LIST Command:  Lists a single line, a range of lines, or your entireprogram; it works just like the LIST command in BASIC. While aprogram or a range of lines is listing, you can momentarily stop thelisting by hitting the space bar. Tapping the space bar again willrestart the listing.  You can abort the listing by hitting the RETURNKey.  The SLOW and FAST commands allow you to control the listingspeed. If you list a single line, it is displayed on the screen in aposition which makes it easy to edit using the Apple II screenediting tools.- 4 ----------------------------------------------------------------------FIND Command:  Search through your source program for a given textstring, and list all the lines which contain that string. You maytype FIN or FIND, followed by a space, followed by the text stringfor which you are searching.  Every character you type between thespace and the carriage return is part of the search key, so you canprefix or append spaces to the key to perform label searches.Screen Editing:  The Apple II screen editing tools are quite powerfuland actually very easy to use.  However, many owners do not use thembecause of the very limited explanation in the original AppleDocumentation.  Now it is described well in the A~nle II BASICProgramming Nanual (pages 28-30 and 49-55), and the A~~lesoft IIBASIC Reference Manual (pages 54-55 and 110-114).Briefly, the left arrow is a backspace, and deletes one characterfrom the input buffer each time it is used.  The right arrow adds tothe input buffer the character from the screen that the cursor wascovering just before you type the arrow key.  Four escape charactersequences allow you to move the cursor anywhere on the screen youwish without affecting the input bufferi    escape A    Right 1             (if at end of line, go to                                     beginning of next line)    escape B    Left 1              (if at beginning of line, go                                     to end of previous line)    escape C    Down 1 line    escape D    Up 1 lineThese escape character sequences can be a little clumsy, due to thenecessity of hitting the escape key and then a letter for each cursormovement.  S-C ASSEMBLER II allows you to substitute control-A forescape-A, control-B for escape-B, and so on.  The escape sequencesstill work, but you can type faster using the control form.  Thecontrol form is especially nice when you need to repeat the samemotion a number of times.You can edit a source line previously entered by listing it with theLIST command, moving up to it by typing control-D, and then using thearrows, control-A, and control-B to make- 5 ----------------------------------------------------------------------the desired changes.  The right arrow will copy characters into thenew version of the line.  Control-A will skip over characters youwish to omit, and control-B will back up the cursor so you can insertnew characters.  To change characters on a one-for-one basis, simplytype over the top of the old ones.  When you are through, hit theRETURN key.Another way to edit a line is to re-type the entire line. The newversion will replace the old one with the same line number.S-C ASSEMBLER II implements one additional editing feature,tabulation.  The control-I key will cause enough blanks to be enteredto tab over to the next tab stop.  Tab stops are preset at columns12, 16, and 26.  (See Appendix A for instructions on changing the tabstops to different values.)Listing Control CommandsFAST Command:  Sets the listing speed to the normal~toofast-to-readspeed.  It also turns off the printer software if it was on.  Whenyou first enter S-C ASSEMBI£R II, it is already in the FAST mode.  Ifyou abort a listing or assembly by hitting the RETURN key, the systemreturns to the FAST mode.SLOW Command:  Sets the listing speed slow enough that you can read itas it goes by on your screen.  It also turns off the printer softwareif it was on.PRT Command:  Turns on the printer software.  All output will be sentto the printer as well as to the TV screen.  S-C ASSEMBLER IIincludes a printer driver for the Practical Automation DMTP-6uPprinter, connected through the game i/o connector.  You can easilysubstitute your own printer software in its place (See Appendix C fordetails).  If you have the Apple parallel or serial printer interfaceboards, you use the PR#slOt command to turn on y~ur printer insteadof the PRT command.- 6 ----------------------------------------------------------------------Object CommandsASM Command:  Initiates assembly of your source program. S-C ASSEMBLERII is a two-pass assembler.  During the first pass it builds a symboltable with the definition of every label used in your program.During the second pass the assembler stores object code into memoryand produces an assembly listing.  At the end of the second pass alist of all the labels and their definitions is produced.  Thesymbols are listed in the same order in which they were defined.If any errors are detected during either pass, an error message willbe printed.  The message will briefly explain the nature of theerror, and indicate the line number of the bad line.  All of thesemessages abort the assembly process, so that you can fix themimmediately and re-start the assembly.The assembly listing can be momentarily interrupted and restarted byusing the space bar, just as with the LIST command.  You can alsoabort the assembly during pass two by hitting the RETURN key.MGO Command:  Begins execution of your object program.  An expression(see OPERAND EXPRESSIONS later in this manual) must follow the MGOcommand to define the place to begin execution.  For example, '1MGOBEGIN" will cause execution to begin at the point in your programwhere the label BEGIN is defined.  Your program can return to S-CASSEMBLER II either by using an '1RTS" instruction, or by a "JMP~1OO5." You may also abort your program by hitting the RESET key1 andthen use iOO3G in the monitor to return to the assembler system.Note: A source program MUST be assembled using the ASM command beforeit can be executed with the MGO command:The MGO command is named "MGO" rather than "RUN" due to a namingconflict with Apple DOS.- 7 ----------------------------------------------------------------------Tape CommandsThree commands are included in S-C ASSEMBLER II to allow you tomaintain source programs on cassette tape.LOAD Command:  Deletes the current source program, if any, and thenreads in a new one from cassette tape.  It works exactly the same asthe LOAD command in BASIC.SAVE Command:  Writes the source program in memory on cassette tape.It works exactly the same as the SAVE command in BASIC.JOIN Command:  Reads a program from cassette tape and positions it infront Qf a program already in memory. The JOIN command allows you tojoin two programs into one. JOIN does not renumber the lines, anddoes not re-sort the lines of the combined program into line-numberorder. After the JOIN is complete, you should first delete any excesslines (such as the ".EN" from the newly-read portion), and then usethe RENUMBER command to assign new line numbers to all the lines.The JOIN command is named "JOIN" rather than "APPEND" due to a namingconflict with Apple DOS.DOS COMMANDSAll the Apple DOS commands are valid, even though you are operatingfrom within S-C ASSEMBLER II.  This feature allows you to maintainyour source and object programs on disk using the LOAD, SAVE, BLOAD,and BSAVE commands.  Source programs will be entered into the diskcatalog with a type code of "I", just as though they were IntegerBASIC programs.Be sure to avoid typing the "RUN filename" command, because it willbe recognized by DOS as an attempt to load and execute an IntegerBASIC or Applesoft program.  However, since the DOS links have beenset up for S-C ASSEMBLER II, the program will not execute.  It willjust clobber any source program you may have had in memory!- 8 ----------------------------------------------------------------------Housekeeping Commands: The Apple DOS housekeeping commands (INIT,CATALOG, RENAME, DELETE, LOCK, UNLOCK, VERIFY, NON, NOMON, andMAXFILES) can be used as you desire.  They will function exactly thesame within S-C ASSEMBLER II as they do within BASIC.Source Maintenance Commands: The LOAD and SAVE commands when usedwith a file name will be interpreted by DOS.  If no file name isincluded, S-C ASSEMBLER II will interpret them as cassette tapecommands.  As mentioned before, you should not use the RUN commandwhen you are inside S-C ASSEMBLER II, or you will just lose yourcurrent source program.  (Same thing goes for the CHAIN command.)Object Maintenance Commands: The BSAVE, BLOAD, and BRUN commands maybe used to maintain object programs on the disk and to execute them.Be careful when using BLOAD and BRUN that the program you are loadingdoes not load on top of anything you want to keep!I/O Selection Commands: The PR#, IN#, and EXEC commands may be usedfrom within S-C ASSEMBLER II.  PR# is used to turn on the standardApple parallel or serial printer interface cards.  EXEC could be usedin many ways; one use might be to load a source program created bysome other editor as a text file (type code "T") on the disk.  TheIN# command will virtually be ignored, because the line input routineinside S-C ASSEMBLER II resets input to keyboard before every line isread.BASIC Commands: The INT and FP commands may be used to exit the S-CASSEMBLER II and enter Integer BASIC or Apple soft.- 9 ----------------------------------------------------------------------MONITOR COMMANDSAll of the Apple II Monitor commands are available from within S-CASSEMBLER II.  You use them by typing a dollar sign ($) after theprompt symbol, followed by the monitor command you wish to use.  Thisis the same feature available in the AppleII  Mini-Assembler.Apple II Monitor commands are explained on pages 68-71 of the redApple II Reference Manual.  Withthem you may examine, change, move,verify memory; read and write cassette tapes; dis-assemble machinelanguage programs; execute programs; call the mini-assembler andassemble some 6502 code; perform hexadecimal arithmetic;~and monitorprogram execution for debugging purposes.  The fact that all thesecommands may be used without leaving the S-C ASSEMBLER II systemgreatly increases the facility with which you can develop and debugassembly language programs.        :$4A.4D CA.CD        004A- 00 1D 00 96        00CA- 62 88 00 08        :$1000L        1000-   4C 1B 10    JMP     $101B        1003-   AD 81 C0    LDA     $C081        1006-   20 0F 10    JSR     $100F        1009-   4C 29 10    JMP     $1029        100C-   20 AD E5    JSR     $E5AD        100F-   A9 1D       LDA     #$1D        1011-   85 4B       STA     $4B        1013-   A9 00       LDA     #$00        1015-   85 4A       STA     $4A        1017-   AA          TAX        1018-   81 4A       STA     ($4A,X)        101A-   60          RTS        101B-   20 D7 13    JSR     $13D7        101E-   20 58 FC    JSR     $FC58        1021-   20 0C 10    JSR     $100C        1024-   A0 00       LDY     #$00        1026-   20 F9 12    JSR     $12F9        1029-   A9 B2       LDA     #$B2        102B-   A0 1C       LDY     #$1C        102D-   20 D1 11    JSR     $11D1- 10 ----------------------------------------------------------------------SOURCE PROGRAM FORMATSource programs are entered a line at a time, with a four-digit linenumber identifying each line.  The line numbers may run from 0000through 9999, and leading zeroes on numbers less than 1000 must betyped.  Source program lines are kept sorted in line-number order;the numbers are used for editing purposes, just as in BASIC.  A blankmust always follow the line number.  After the blank, there are fourfields of information: the label, opcode, operand, and commentfields.  Adjacent fields must be separated by at least one blank.Although the fields are not restricted to begin in any particularcolumns, it is convenient to enter them in this way for neatness.Therefore tab stops are built in to the S-C ASSEMBLER II at columns12, 16, and 26.  When you type the control-I character, blanks willbe printed until the next tab stop is reached.  If you are already atthe column right before a tab stop, the next tab stop will be skippedover and blanks will be printed up to the second tab stop. Forinformation about changing the tab stops to different columns, seeAppendix A.Label Field: May be left blank, or may contain a label of from one tosix characters.  The first character of a label must be a letter;remaining characters may be either letters or numbers.  Labels areused to name places in your program to which you will branch, as wellas constants and variables.The standard tab settings leave enough room for only four-characterlabels; however, you can go ahead and use six characters as long asthere is at least one space between the label and the opcode.  If youlike, you may type labels on a separate line, with the opcode andfollowing fields left blank.  The label will be defined as thecurrent value of the location counter.  There aresome examples ofthis in the file on the S-C ASSEMBLER II disk named "SAMPLE.SOURCE".- 11 ----------------------------------------------------------------------Opcode Field: Contains a three-letter machine language mnemonicopcode, an assembler directive, or a SWEET-16 mnemonic opcode.  Ifyou are using the tab stops, the opcode field normally starts incolumn 12.  However, opcodes may begin in any column after at leastone blank from a label or two blanks from a line number.S-C ASSEMBLER II uses the standard 6502 instruction mnemonics, whichare listed in the Apple II Reference Manual on pages 100-105.Assembler directives and SWEET-16 opcodes are discussed later in thismanual.Operand Field: Usually contains an operand expression of some sort.Some of the 6502 instructions have no written operand, such as NOP,BRK, DEX, and others.  In these cases the comment field may bestarted right after the opcode. Four of the opcodes (ROL, ROR, ASL,and ASR) may be used both with and without an operand.  If no operandis present, you must type at least two blanks before a comment withthese four opcodes.Comment Field: Comments are separated from the operand field by atleast one blank.  For your convenience, a tab stop for comments isset at column 26.  In the assembly listing, they will start at column~1, which is the beginning of the next line on your TV screen.Actually comments may begin earlier or later on the line, just so atleast one blank separates them from the operand expression.Comment Lines: Full lines of comments may be entered by typing anasterisk (*) in the first column of the label field. This type ofcomment is useful in separating various routines from each other, andlabeling their contents.  It is analogous to the REM statement inBASIC.Lines which are completely blank are also treated as comments.- 12 ----------------------------------------------------------------------Samp1e Source Program1000 *1010 *    MONITOR CALLS1020 *1030 DLAY .EQ $FCA8     DELAY SUBROUTINE1040 COT1 .EQ $FDF0     CHARACTER OUTPUT1050 SOFT .EQ $3D0      DOS SOFT RE-ENTRY1060 IOHOOK .EQ $3EA    DOS I/O HOOK ROUTINE1070 *1080 *    I/O ADDRESSES1090 *1100 KEY  .EQ $C000     KEYBOARD INPUT1110 KEYS .EQ $C010     KEYBOARD STROBE1120 *1130 *    SET UP SLOW-LIST1140 *1150 SLOW LDA #SLOLST   PUT POINTER IN OUTPUT VECTOR1160      STA $361170      LDA /SLOLST1180 SLS1 STA $371190      JMP IOHOOK    GET DOS TO HOOK IT IN1200 *1210 *    SET UP FAST-LIST1220 *1230 FAST LDA #FSTLST1240      STA $361250      LDA /FSTLST1260      BNE SLS11270 *1280 *    SLOW-LIST ROUTINE1290 *1300 SLOLST1310      CMP #$8D      IS IT CR?1320      BNE SLW4      NO, SO PRINT IT1330      LDA #0        YES, SO SLOW DOWN1340      JSR DLAY      MONITOR DELAY ROUTINE1350 SLW1 LDA KEY       CHECK IF KEY TYPED1360      BPL SLW3      NO, OUTPUT CR1370      STA KEYS      YES, CLEAR STROBE1380      CMP #$8D      IS IT CR?1390      BEQ SLW5      YES, SO ABORT1400 SLW2 LDA KEY       NO, SO SUSPEND1410      BPL SLW2      WAIT FOR KEY1420      STA KEYS      CLEAR STROBE1430      CMP #$8D      IS IT CR?1440      BEQ SLW5      YES, SO ABORT1450 SLW3 LDA #$8D      OUTPUT CR1460 SLW4 JMP COT1      MONITOR CHAR OUTPUT1470 SLW5 JMP SOFT      ...ABORT...1480 *1490 *    FAST-LIST ROUTINE1500 *1510 FSTLST1520      CMP #$8D      IS IT CR?1530      BNE SLW4      NO, SO KEEP LISTING1540      BEQ SLW1      YES; SO CHECK FOR KEYS1550      .EN- 13 -------------------------------------------------------------------------------------------------------------------------------------------ASSEMBLER DIRECTIVESSeven assembler directives are available in S-C ASSEMBLER II tocontrol the assembly process and to define data in your programs.These are all indicated by a three-character mnemonic, in the form ofa period followed by two letters.    .OR     ORigin    .TA     Target Address    .EN     ENd of program    .EQ     EQuate    .DA     DAta    .AS     Ascii String    .HS     Hex StringOrigin:             .OR exprSets the program origin and the target address to the value of theexpression.  Program origin is the address at which the objectprogram will be executed.  Target address is the memory address atwhich the object program will be stored during the assembly.  The .ORdirective sets both of these to the same value, which is the normalway of operating.  If you do not use the .OR directive, the assemblerwill set both the program origin and the target address to $0800.  Ifthe "expr" is not defined during pass one prior to its use in the .ORdirective, an error message is printed and assembly is aborted(***UNDEF AT LINE ....).Target Address:     .TA exprSets the target address at which object code will be stored duringassembly.  The target address is distinct from the program origin(which is either set by the .OR directive, or is implicitly set to$0800).  The .OR directive sets both the origin and the targetaddress; the .TA directive sets only the target address.  Object codeis produced ready to run at the program origin, but is storedstarting at the target address.- 15 ----------------------------------------------------------------------When you wish to assemble a program which will execute at an addressnormally occupied by the assembler ($1000 through $1CFF)*, the symboltable ($1D00 *up), or the source program text (bottom of DOS down),you need to use the .TA and .OR directives.  Set the origin first,using the .OR directive; then set the target address to a safe valueusing the ·TA directive.  It is always safe to start the target areaat $0800, providing your object code does not extend beyond $0FFF.    :ASM                    1000 *     SAMPLE PROGRAM TO ILLUSTRATE                    1010 *     THE ".TA" DIRECTIVE                    1020      .OR $1000                    1030      .TA $0800    1000- AD 0C 10  1040 DEMO LDA AVALUE    1003- AE 0D 10  1050      LDX XVALUE    1006- AD 0E 10  1060      LDY YVALUE    1009- 4C 00 10  1070      JMP DEMO                    1080 *    100C- 0C        1090 AVALUE .DA #12    100D- 22        1090 XVALUE .DA #34    100E- 38        1090 YVALUE .DA #56    SYMBOL TABLE    DEMO    1000    AVALUE  100C    XVALUE  100D    YVALUE  100EAs you can see in the example, the assembly listing looks as thoughthe program were stored at $1000.  However, the object code isactually stored at $0800, which is the target address set in the .TAdirective.  If we dis-assemble memory starting at $0800, we see::$800L0800-   AD 0C 10    LDA     $100C0803-   AE 0D 10    LDX     $100D0806-   AC 0E 10    LDY     $100E0809-   4C 00 10    JMP     $1000080C-   0C          ???080D-   22          ???080E-   38          SEC* ASMDISK ends at $1CFF, symbols start at $1D00. ASMDISK (AUTOSTART)ends at $1DFF, symbols start at $1E00.  ASMDISK (APPLE II PLUS) endsat $1FFF, symbols start at $2000.- 16 ----------------------------------------------------------------------After the assembly is complete, there are several ways to positionthe code in memory where it really should be.  You can save theobject code on cassette or disk from its current location, andre-load it later at the correct location for execution.  Be sure youdo not try to reload it while you are executing the assembler, or youmay clobber it!Another method is to hit RESET and use the monitor memory movecommand ( addrl addr2.addr3M ).  This command will move the block ofmemory from addr2 through addr3 to the area beginning at addri.If you need a larger safe area than that given between $0800 and$0FFF, you can patch the assembler at location $1010.  This locationcurrently contains $1D, which is the page number of the start of theassembler's symbol table.  If you change this value to $30, forexample, the symbol table will start at $3000 instead of $1D00.  Thiswill leave the area from $1D00 through $2FFF free for a target area.To be effective, this change should be made before using the ASMcommand.  Be sure to leave enough room between the start of thesymbol table and the bottom of DOS for all of your source program aswell as the symbol table.End of Program:     .ENDefines the end of the source program.  You would normally make thisthe last line, but you may place it earlier in order to assemble onlya portion of your source program.  If no .EN is present anywhere inyour program, the assembler will assume you meant to put one afterthe last line.  (This is different from most assemblers, which forsome strange reason go completely crazy if the .EN directive ismissing!)* These values are correct for ASMDISK.  For ASMDISK (AUTOSTART) thevalues are $1E and $1E00.  For ASMDISK(APPLE II PLUS) the values are$20 and $2000.- 17 ----------------------------------------------------------------------Equate:     label .EQ exprDefines the label to have the value of the expressione If theexpression is not defined, an error message is printed (***UNDEF ATLINE xxxx).  If you neglect to use a label with an equate directive,an error message is printed also (***NO LABEL AT LINE xxxx).  Ineither case, the assembly is aborted so that you can repair theerror.  One common use for this directive is to define all thepage-zero variables your program uses.                    1000 ACC    .EQ $45                    1010 IN     .EQ $0200   INPUT BUFFER                    1020 ACL    .EQ $50                    1030 ACH    .EQ ACL+1                    1040 PDL0   .EQ $C064   PADDLE 0    SYMBOL TABLE    ACC     0045    IN      0200        ACL     0050    ACH     0051    PDL0    C064Data:       label .DA expr  (two bytes, LSB first)            label .DA #expr (one byte, LSB of expr)            label .DA /expr (one byte, MSB of expr)Creates a constant or variable in your program.  The value of theexpression, as one or two bytes, is stored at the current location.If a label is present, it is defined as the address where the firstbyte of data is stored.  (If you use .DA to define a variable, it isa good habit to use an expression like "*-*", which has a value ofzero.  This weird expression will make your program moreself-explanatory when you look at it again next year.)                    1000 IN   .EQ $0200     INPUT BUFFER    0800- E8 03     1010 TEN3 .DA 1000    0802- 64 C0     1020 PDL0 .DA $C064     PADDLE 0 ADDRESS    0804- C1        1030 LTRA .DA #$C1      ASCII LETTER A    0805- 02        1040 BFPG .DA /IN       BUFFER PAGE    SYMBOL TABLE    IN      0200    TEN3    0800    PDL0    0802    LTRA    0804    BFPG    0805- 18 ----------------------------------------------------------------------Hex String:     label .Hs hhh...hConverts a string of hex digits (hhh...h) to binary, two digits perbyte, and stores them starting at the current location.  If a labelis present, it is defined as the address where the first byte isstored.  If you do not have an even number of hexadecimal digits, theassembler aborts with an error message (***BAD ADDRESS AT LINE xxxx).NOTE: Unlike hexadecimal numbers used in operand expressions, youmust not use a dollar sign with the .HS directive.A funny feature of this assembler is that the source line will printtogether with the last line of bytes produced by the hex stringdirective.  Do not let this confuse you.    0800- F1        0900      .HS F1    0801- 23 AB 45  1000 STR  .HS 23AB45    0804- 01 23 45    0807- 67 89 AB    080A- CD EF     1100 QT   .HS 0123456789ABCDEF    SYMBOL TABLE    STR     0801    QT      0804Ascii String:   label .AS daaa...adStores the binary form of the ASCII characters "aaa...a" insequential locations beginning at the current location.  If a labelis present, it is defined as the address where the first character isstored.  The string "aaa...a" may contain any number of the printingASCII characters.  You indicate the beginning and end of the stringby any delimiter !1d11 that you choose.ASCII character codes are seven bit values.  The .AS directivenormally sets the high-order, or 8th, bit to zero.  Some people liketo use ascii codes with the high-order bit set to one, so S-CASSEMBLER II includes an option for this.    .AS daaa...d     sets the high-order bits to 0    .AS -daaa...d    sets the high-order bits to 1This syntax restricts the choice of the delimiter slightlys it may beany printing character other than space and minus.- 19 ----------------------------------------------------------------------    0800- 53 54 52    0803- 49 4E 47  1000 STR  .AS "STRING"    DELIMITER IS "    0806- 22 22 22  1010 QT   .AS /"""/       DELIMITER IS /    0809- C8 D5 C8    080C- BF        1020 HUH  .AS -QHUH?Q     DELIMITER IS ?    SYMBOL TABLE    STR     0800    QT      0806    HUH     0809- 20 ----------------------------------------------------------------------OPERAND EXPRESSIONSOperand expressions are written using terms and operators. The validoperators are + and -.  Terms may be decimal numbers1 hexadecimalnumbers, labels, or an asterisk (*).  The first term in an expressionmay be preceded by a + or - sign.Decimal Numbers: Any number in the range from 0 through 65535,written in the normal way.    0800- A9 C8     1000      LDA #200    0802- A2 F6     1010      LDX #-10    0804- 6B 8B     1020      .DA 35691                    1030 FLAG .EQ -1Hexadecimal Numbers: Any number in the range from $0 through $FFFF.Hexadecimal numbers are indicated by a preceding dollar sign, and mayhave from one to four digits.                    1050      .OR $880    0880- A9 2F     1060      LDA #$2F    0882- 85 CA     1070      STA $CA    0884- D0 1D     1080      BNE $8A3    0886- 20 2A E0  1090      JSR $E02A                    1100 VALL .EQ $AB                    1110 NUM  .EQ $1278                    1120 CONV .EQ $E59BBeware of leaving out the dollar sign; the assembler may be quitesatisfied to think of your hexadecimal number as a decimal one if youomit the $.  In some cases even a number with letters in it, such as23AB,may be acceptable; it may be interpreted as decimal 23 and acomment "AB".Labels: One to six characters; the first character must be a letter,while the others may be either letters or digits. Labels must bedefined somewhere in the program if they are to be used in anexpression.  In some cases they must be defined prior to use inexpressions to prevent an undefined or ambiguous location counter.For example, if the expression in the operand field of an origin(".OR") directive is not defined prior to use, the assembler will notknow how to define any subsequent labels.- 21 ----------------------------------------------------------------------A problem can occur if you postpone the definition of page-zerovariables until after their use in operand expressions.  If theselabels are used with instructions which could assume both absoluteand zero-page address modes, a discrepancy in the location count willoccur between pass one and pass two of the assembler.  (Thisdiscrepancy cannot be detected by the present design of theassembler, so make it a habit to always define your page-zerovariables at the beginning of your program.)                    1000 VALL .EQ $AB                    1010 NUM  .EQ $1905                    1020 CONV .EQ $E59B    0800- B5 A8     1030 LP   LDA VALL-3,X    0802- 9D 05 19  1040      STA NUM,X    0805- 20 9B E5  1050      JSR CONV    0808- D0 F6     1060      BNE LPAsterisk (*): Stands for the current value of the location counter.This is useful for storing the length of a string as a constant in aprogram.  I also use it in the expression "*-*" to indicate that alocation is a variable rather than a constant.    080A- 0B        1070 QT   .DA #QTSZ     # BYTES IN MSG    080B- 41 4E 59    080E- 20 4D 45    0811- 53 53 41    0814- 47 45     1080      .AS /ANY MESSAGE/                    1090 QTSZ .EQ *-QT-1    # OF BYTES IN MSG    0816- 00 00     1100 VARW .DA *-*       2-BYTE VARIABLE    0818- 00        1110 VARB .DA #*-*      1-BYTE VARIABLE                    1120 HERE .EQ *It is considered very poor programming practice to include branchinstructions in your program with operand expressions of the form"*-5" or "*+7".  Avoid them like the plague!  They breed bugs thatcan be very difficult to find.  Don't be afraid to use another labelor two, no matter how silly the names might sound.- 22 ----------------------------------------------------------------------ADDRESSING MODESThe MOS Technology 6502 microprocessor used in the Apple II has manygreat features; one of the greatest is its variety of addressingmodes.  There are thirteen different modes in all, though no singleopcode can use every one of them.  The charts in this chapter showwhich modes can be used with each opcode.  But first, here is a chartshowing an example of each mode and the way it is written in assemblylanguage.  Except for one new kind, the syntax is the same as thatused by the Apple II mini-assembler.    Mode            Example    Implied         DEX              \  At least two    Accumulator     ROL              /  blanks before                                        comments begin.    Relative        BNE expr    Immediate       LDA #expr                    LDA /expr    Zero Page       LDA expr         \    Absolute        LDA expr         |  Assembler uses                                     |  Zero Page form    ZeroPage,X      LDA expr,X       |  if possible;    Absolute,X      LDA expr,X       |  if not, it uses    Zero Page,Y     LDA expr,Y       |  Absolute form.    Absolute,Y      LDA expr,Y       /    (Zero Page,X)   LDA (expr,X)    (Zero Page),Y   LDA (expr),Y    (Absolute)      JMP (expr)For a full explanation of the modes and how to use them, I refer youto the MOS Technology Hardware and Programming Manuals, as well asthe other references mentioned in the bibliography in Appendix D.S-C ASSEMBLER II has one syntactical addition over the Apple IImini-assembler.  The immediate mode may be indicated by either apound sign (#) or a slash (/).  The "#" means that the leastsignificant byte of the 16-bit expression value should be used(equivalent to "expr MOD 256" in BASIC).- 23 ----------------------------------------------------------------------The "/" means that the most significant byte should be used(equivalent to "expr/256" in BASIC).One use for this feature is in setting up the address of a subroutineor a buffer in a pointer.  (A pointer is a pair of bytes containingan address which "points" at a subroutine or into a buffer.)  Forexample:                1000 SLOW .EQ $1C890800- A9 89     1010      LDA #SLOW0802- 85 36     1020      STA $360804- A9 1C     1030      LDA /SLOW0806- 85 37     1040      STA $37is used inside S-C ASSEMBLER II to turn on the Slow-List feature whenyou type the SLOW command.Trying to comprehend and remember thirteen different addressing modescan be very difficult; therefore it is convenient to try to groupthem into categories.  I use the following breakdown: implied mode,relative mode, and other modes. "Other" modes now includes elevenmodes, so I break it down further: accumulator, immediate, direct,and indirect modes.  Each of direct and indirect modes may be eitherindexed or not indexed, and either zero page or Absolute.  Thefollowing outline will give you a better idea of what I am describing.            I.   Implied            II.  Accumulator            III. Direct                 A. Not Indexed                    1.  Zero Page                    2.  Absolute                 B. Indexed by X-register                    1.  Zero Page,X                    2.  Absolute,X                 C. Indexed by Y-register                    1.  Zero Page,Y                    2.  Absolute,Y            IV. Indirect                A. Not Indexed -- (Absolute)                B. Indexed by X-register (Zero Page,X)                C. Indexed by Y-register (Zero Page),Y- 24 ----------------------------------------------------------------------Implied Mode: In this mode, the address is implied by the nature ofthe instruction; the operand field is left blank.  All of the opcodesin this class are only one byte long.  They are:        BRK     DEX     PHA     RTS     TAY        CLC     DEY     PHP     SEC     TSX        CLD     INX     PLA     SED     TXA        CLI     INY     PLP     SEI     TXS        CLV     NOP     RTI     TAX     TYARelative Mode: This mode is used only by the conditional branchinstructions.  The expression is converted to a signed offset fromthe location following the branch instruction.  The result must be inthe range from -128 through +127 to be legal.  All of theseinstructions occupy two bytes.  They are:        BCC     BEQ     BNE     BVC        BCS     BMI     BPL     BVSOther Modes: Usage of the other eleven modes is much more complex.The table on the next page shows which modes are defined for each ofthe remaining opcodes.  These instructions occupy one byte in theaccumulator mode, two bytes in any of the zero page modes, and threebytes in any of the absolute modes.  They are:        ADC     AND     ASL     BIT     CMP        CPX     CPY     DEC     EOR     INC        LDA     LDX     LDY     LSR     ORA        ROL     ROR     SBC     STA     STY        STX     JMP     JSRYou might notice especially that only four opcodes are usable in theaccumulator mode (ASL, LSR, ROL, ROR); that only two opcodes use the"ZP,Y" mode (LDX and STX); and that only one opcode uses theindirect absolute non-indexed mode (JMP).- 25 ----------------------------------------------------------------------      ACCUM-   IMMED-  ---- D I R E C T ----    ---- I N D I R E C T ----      ULATOR   IATE               INDEXED               INDEXED      blank    #expr   expr    expr,X  expr,Y   (expr)  (expr,X)  (expr),Y               /expr   ZP/ABS  ZP/ABS  ZP/ABSADC     --      69     65/6D   75/7D   --/79      --       61       71AND     --      29     25/2D   35/3D   --/39      --       21       31ASL     0A      --     06/0E   16/1E   --/--      --       --       --BIT     --      --     24/2C   --/--   --/--      --       --       --CMP     --      C9     C5/CD   D5/DD   --/D9      --       C1       D1CPX     --      E0     E4/EC   --/--   --/--      --       --       --CPY     --      C0     C4/CC   --/--   --/--      --       --       --DEC     --      --     C6/CE   D6/DE   --/--      --       --       --EOR     --      49     45/4D   55/5D   --/59      --       41       51INC     --      --     E6/EE   F6/FE   --/--      --       --       --LDA     --      A9     A5/AD   B5/BD   --/B9      --       A1       31LDX     --      A2     A6/AE   --/--   B6/BE      --       --       --LDY     --      AO     A4/AC   B4/BC   --/--      --       --       --LSR     4A      --     46/4E   56/5E   --/--      --       --       --ORA     --      09     05/0D   15/1D   --/19      --       01       11ROL     2A      --     26/2E   36/3E   --/--      --       --       --ROR     6A      --     66/6E   76/7E   --/--      --       --       --SBC     --      E9     E5/ED   F5/FD   --/F9      --       E1       F1STA     --      --     85/8D   95/9D   --/99      --       81       91STX     --      --     86/8E   --/--   96/--      --       --       --STY     --      --     84/8C   94/--   --/--      --       --       --JMP     --      --     --/4C   --/--   --/--      6C       --       --JSR     --      --     --/20   --/--   --/--      --       --       --- 26 ----------------------------------------------------------------------SWEET-16SWEET-16 is the little 16-bit interpreter Steve Wozniak wrote, whichis hidden inside your Apple Integer BASIC ROM's.  He described itfully in BYTE Magazine, November, 1977, pages 150-159: "SWEET-16 --The 6502 Dream Machine". The same article is available directly fromApple, or in one of the many editions of the "WOZPAK".Many people have begged me to include the ability to assemble codefor SWEET-16 in the S-C ASSEMBLER II, so I have now done so.  (It isincluded in versions 3.2 and later.)  I have implemented the samemnemonics and syntax which Steve Wozniak described in the article.The beauty of SWEET-16 is in its ability to perform 16-bit arithmeticand data moves using automatically updated address pointers.  And toadd icing to the cake, most of the instructions are only one bytelong!  You can write extremely compact code, if you are willing topay the price of slower execution.  Portions of S-C ASSEMBLER II arecoded in SWEET-16; these include the RENUMBER command processor andthe opcode table search routine.SWEET-16 is invoked by the instruction "J5R $F689", and the bytesimmediately after this instruction should contain opcodes forSWEET-16 to process.  If you are serious about wanting to learn touse SWEET-16, locate the article and start studying.    1n lo hi    SET  n,addr         01 ea   BR   addr    2n          LD   n              02 ea   BNC  addr    3n          ST   n              03 ea   BC   addr    4n          LD   @n             04 ea   BP   addr    5n          ST   @n             05 ea   BM   addr    6n          LDD  @n             06 ea   BZ   addr    7n          STD  @n             07 ea   BNZ  addr    8n          POP  @n             08 ea   BM1  addr    9n          STP  @n             09 ea   BNM1 addr    An          ADD  n              0C ea   BS   addr    Bn          SUB  n    Cn          POPD @n             00      RTN    Dn          CPR  n              0A      BK    En          INR  n              0B      RS    Fn          DCR  n* This is the address of SWEET-16 in the Integer BASIC ROM. If youare using ASMDISK (APPLE II PLUS), SWEET-16 begins at $1D89, insidethe assembler.- 27 ----------------------------------------------------------------------                    1000      .OR $11DE                    1010      .TA $0800                    1180 HIMM .EQ $4C      TOP OF SOURCE                    1410 SW16 .EQ $F689    SWEET-16                    4080 *                    4090 *    RENUMBER COMMAND                    4100 *    11DE- 20 89 F6  4110 REN  JSR SW16      CALL SWEET-17    11E1- 11 CA 00  4120      SET 1,PP      POINT AT PP    11E4- 61        4130      LDD @1        GET PP    11E5- 31        4140      ST  1         (R1)=PP    11E6- 12 0A 00  4150      SET 2,10      INCREMENT = 10    11E9- 13 4C 00  4160      SET 3,HIMEM   POINT AT HIMEM    11EC- 63        4170      LDD @3        GET HIMEM    11ED- 33        4180      ST  3         (R3)=HIMEM    11EE- 14 DE 03  4190      SET 4,990     START=990    11F1- 21        4200 REN1 LD  1         TEST IF THRU    11F2- D3        4210      CPR 3    11F3- 03 0E     4220      BC  REN2      FINISHED    11F5- 41        4230      LD  @1        GET # BYTES    11F6- 35        4240      ST  5         SAVE FOR LATER    11F7- 24        4250      LD  4         GET SEQ. NO.    11F8- A2        4260      ADD 2         ADD INCREMENT    11F9- 34        4270      ST  4         STORE NEXT SEQ. NO.    11FA- 71        4280      STD @1        PUT SEQ: NO. IN    11FB- F1        4290      DCR 1         BACK UP POINTER    11FC- F1        4300      DCR 1    11FD- F1        4310      DCR 1    11FE- 21        4320      LD  1         MOVE TO NEXT    11FF- A5        4330      ADD 5    1200- 31        4340      ST  1    1201- 01 EE     4350      BR  REN1    1203- 00        4360 REN2 RTN    1204- 60        4370      RTS    SYMBOL TABLE    HIMM    004C    SW16    F689    REN     11DE    REN1    11F1    REN2    1203- 28 ----------------------------------------------------------------------APPENDIX AOperation and Memory Usa~eVersion 3.2 of S-C ASSEMBLER II is a disk-based version, and issupplied on an Apple DOS 3.2.1 Master Disk.Contents of the Disk: The disk contains standard Apple DOS 3.2.1, andseven files.  When you boot the disk, if your Apple has Integer BASICROMs, the following catalog will print:        S-C ASSEMBLER II -- DISK VERSION 3.2        COPYRIGHT JUNE #), 1979        DISK VOLUME 001        I 002 HELLO        B 015 ASMDISK        I 008 SAMPLE.SOURCE        I 011 APPLE-TALKER        I 003 USEFUL INFORMATION (BASIC)        B 016 ASMDISK (AUTOSTART)        B 018 ASMDISK (APPLE II PLUS)(If your Apple does not have Integer BASIC in ROM, or in RAM with thePascal Language System, you will get the message "LANGUAGE NOTAVAILABLE" instead of a catalog when you boot the disk.  Don't worryabout this; just type the CATALOG command and you will get one.  Youcan change the HELLO program to an Applesoft version later.)The three files with names containing "ASMDISK" are three versions ofthe S-C ASSEMBLER II, for the three different configurations of AppleII computers.  If you have an Apple II with the standard monitor ROMand with Integer BASIC, you can use the shortest version: ASMDISK.If you have Integer BASIC either in ROM or in the Pascal System RAMboard, with the Autostart Monitor ROM, use the next version: ASMDISK(AUTOSTART). If you do not have Integer BASIC at all, usethe versioncalled ASMDISK (APPLE II PLUS).  SAMPLE.SOURCE and APPLE-TALKER arenot Integer BASIC programs.  They are sample assembly languageprograms, and are described on page A-4 in this appendix.When you have decided which version of the assembler you are goingto use, simply BRUN the file.  (ASMDISK (APPLE II PLUS) must beBRUNned from Applesoft; the other two versions must be BRUNned fromInteger BASIC.)    >BRUN ASMDISK   or   >BRUN ASMDISK (AUTOSTART)    >BRUN ASMDISK (APPLE II PLUS)A - 1---------------------------------------------------------------------Memory Usage: The S-C ASSEMBLER II program is 3328* bytes long, andresides from $1000 through $1CFF* in memory.  To operate, you need atleast a 24K Apple; remember that Apple DOS uses over 10K for itself.Your source program is stored with the highest numbered line at thehigh end of memory (right under DOS).  The lines are kept innumerical order, the same way as Apple BASIC does it. Locations $CAand $CB contain the address of the beginning of the source program.During assembly, a symbol table is built.  It begins at $1D00 andgrows toward the source program.  (If they meet you get *** MEM FULLERR.)The assembler stores your object code wherever you direct it with the".OR" or ".TA" directives.  If you do not use either of these, theobject code will be stored starting at $0800.  You should be carefulnot to direct the object code on top of the assembler, your sourceprogram, or the symbol table!Many locations in page zero are used during editing and assembly.The only ones which must be protected while you execute your objectprogram are $4A through $4D and $CA through $CD.  The high end ofpage one is used as a stack (6502 hardware feature).  The low end ofpage two is used as an input buffer (Apple Monitor input routine).* The values are correct for ASMDISK.  For ASMDISK (AUTOSTART) thevalues are 3584, $1DFF, and $1E00.  The values for ASMDISK (APPLE IIPLUS) are 4096, $1FFF, and $2000.A - 2---------------------------------------------------------------------    ROM USAGE    Address         Purpose    E02A         *  Get next byte through $E2,E3    E372         *  Delete range of lines    E38A         *  Locate and delete source line    E3C4         *  Print quote from page $EB00    E523         *  Print line number    E56D,E576    *  Locate source line    EED3         *  Print error message    F115         *  Print "ERR"    F11E,F12C    *  Set up for LOAD command (cassette)    F137         *  Decrement limit    F140         *  SAVE command (cassette)    F689         *  SWEET-16 Interpreter    FB63         *  16-bit multiply    FC30            Handle screen-editing characters    FCA8            Delay    FC58            Clear screen    FD0C            Character input    FD1B            Keyboard input    FD67            Read input line    FD9E            Print minus sign.    FDDA            Print (A-register) in hexadecimal    FDED,FDF0       Character output    FE00            Display memory in hexadecimal    FEFD            Cassette tape read    FF3A            Ring bell    FFA7            Get hexadecimal number    FFBE            Jump into monitor command processor    FFC7            Clear mode byte    FFCC            Table of monitor commands* These routines are not referenced by the Apple II Plus version ofS-C ASSEMBLER II.  Also, the routine at FB63 is not referenced fromthe Autostart ROM version.A - 3---------------------------------------------------------------------Sample Source Programs: Two sample source programs have been includedon the S-C ASSEMBLER II disk.  These are intended to illustrate a fewof the neat features of S-C ASSEMBLER II. However, they havefunctional value as well.APPLE-TALKER consists of three programs.  The first, "RCRD", simplyechoes through the Apple speaker whatever it hears at the cassetteinput port.  If you play a tape that you have previously recorded youvoice on, and adjust the volume control until it sounds best, you canhear the Apple's rendition of your voice.  (It is interesting to trythis with other sounds as well, like music.)  The second program,"READ", is similar; however, it not only listens to the cassetteinput port, but also stores the bits in a big buffer.  The thirdprogram, "TALK", plays back all the bits from the big buffer.  Youcan use the basic techniques out of these programs to build somereally fancy frills for your game and demo routines.SAMPLE.SOURCE contains a subroutine similar to my "SLOWLIST" program,which was published in MICRO (July, 1978).  The difference is thatthis version works with DOS 3.2.  It is very similar to the speed andsuspension control I have included in S-C ASSEMBLER II.Useful Information: The last file on the S-C ASSEMBLER II disk iscalled "USEFUL INFORMATION (BASIC)".  This is a BASIC program whichwill BLOAD the assembler and look into certain locations to determinethe current values of the tab stops and the RENUMBER base andincrement.  It will then print the data out in a nice little report.If you make some changes to any of these parameters, this programcould keep you straight as to which version is which.  Of course youcan also glean from the program just where these items of informationare kept inside the assembler.A - 4---------------------------------------------------------------------Handy Patches: Many customers have requested patches for the tabstops, and for the RENUMBER parameters.  In the current release ofS-C ASSEMBLER II (Disk Version 3.2), the locations to change are asfollows:    11EF,11F0   (DE 03)     base - increment (99010)    11E7,11E8   (0A 00)     increment    13A1        (09)        first tab stop   \    13A5        (0D)        second tab stop  |  column number    1394        (17)        third tab stop   /  minus three    1390        (89)        tab control character (Ic)Some customers have complained about the disappearance of theassembler's symbol table after RESET and soft re-entry.  You canre-establish all the assembled symbols except the first one bypatching a non-zero value at $1D00 after re-entry.A - 5---------------------------------------------------------------------APPENDIX BError MessagesIf you make a mistake, S-C ASSEMBLER II will probably catch you.Here are the error messages you may see.    *** SYNTAX ERROR            Misspelled command or bad line number.    *** MEM FULL ERR            Either you do not have enough memory                                for the source program, or for the                                source plus the symbol table, or a                                tape read error has occurred.    *** RANGE ERR AT LINE xxxx  The relative offset for a branch                                instruction was not between -128 and +127.    *** NO LABEL AT LINE xxxx   There was no label with an equate (.EQ)                                directive.    *** BAD OPCODE AT LINE xxxx The characters in the opcode field are                                not a valid opcode or directive.    *** EXTRA DEF AT LINE xxxx  The same label was defined more than                                once.    *** UNDEF AT LINE xxxx      A symbol in the operand field is not                                defined.    *** BAD SYMBOL AT LINE xxxx A character in the label field is not                                a legal character for a label.    *** BAD ADDRESS AT LINE xxxx  This one is a catch-all for syntactical                                errors in the operand expression, as well                                as for use of a particular address mode                                with an opcode that does not support that                                mode.The "xxxx" in the above error messages will be the line number ofthe line with the error in it.In all cases when an error is discovered during assembly, the errormessage will be printed and then assembly will abort.  You can thenlist the indicated line, repair the problem, and try again.B - 1---------------------------------------------------------------------APPENDIX CPrinter SoftwareThe PRT command turns on the self-contained printer software byinserting its starting address at locations $36 and $37, and thencalling the IOHOOK routine in DOS at $03EA.  If you have the Appleparallel or serial printer interface boards, you will not use the PRTcommand.  Instead, you should use the DOS command PR#n to activateyour printer.The self-contained printer software inside S-C ASSEMBLER II iswritten especially for the Practical Automation DMTP-6uP printer.This printer costs less than $700 including power supply andcontroller -- a real bargain.  All it takes to interface theircontroller to the Apple II is to run a twisted pair from theircontroller to the game paddle connector inside the Apple II.  Thesoftware uses one of the TTL outputs at the game connector as a 300baud serial interface.Some features of the printer driver deserve explanation.The printer normally begins printing 1/4 inch from the left edge ofthe paper.  PRT provides left margin control, and is set to actuallybegin printing in column 11.  PRT also keeps track of the number oflines on the page, and pauses after 56 lines so that you can insert anew sheet of paper.  When the paper is ready, tap the space bar tocontinue printing.  PRT optimizes speed to minimize the additionaldelay during a carriage return.  At any time you wish to suspend orabort printing, you use the space bar or RETURN key, just as in theSLOW and FAST modes.A complete listing of the PRT subroutine is included in thisAppendix.  After studying it you should be able to create a similarsubroutine for any other printer you may have. Several customers havewritten to me telling of their success with interfacing the IntegralData, Heathkit, DIABLO, and Centronics printers.  Others are usingSelectrics or Teletypes.C - 1---------------------------------------------------------------------                Listing of the PRT subroutine                1000      .OR $1C00                1010      .TA $0800                1020 *                1030 *    PAGE ZERO VARIABLES                1040 *                1050 CH   .EQ $24       CURSOR HORIZONTAL POSITION                1060 OLDC .EQ $F0       # CHARS PREV LINE                1070 NEWC .EQ $F1       # CHARS THIS LINE                1080 LNCT .EQ $F4       # LINES THIS PAGE                1090 PRTX .EQ $F5       SAVE X                1100 PRTY .EQ $F6       SAVE Y                1110 *                1120 *    ROM-BASED ROUTINES                1130 *                1140 DLAY .EQ $FCA8     DELAY SUBROUTINE                1150 COT1 .EQ $FDF0     COUT AFTER USER EXIT                1160 *                1170 *    SOFT RETURN TO ASSEMBLER                1180 *                1190 SOFT .EQ $1003                1200 *                1210 *    PRINTER DRIVER                1220 *1C00- 84 F6     1230 PRNT STY PRTY      SAVE X AND Y1C02- 86 F5     1240      STX PRTX1C04- C9 8D     1250      CMP #$8D      IS IT CR?1C06- D0 39     1260      BNE PRT5      NO1C08- A4 F0     1270      LDY OLDC      YES, GET # CHARS PREV LINE                1280 *                  WAS LONGER THAN THIS LINE1C0A- C8        1290      INY1C0B- A9 50     1300 PRT1 LDA #80       WAIT A WHILE1C0D- 20 A8 FC  1310      JSR DLAY      MONITOR DELAY1C10- 88        1320      DEY1C11- D0 F8     1330      BNE PRT11C13- A9 8D     1340      LDA #$8D      OUTPUT CR1C15- 20 66 1C  1350      JSR POUT1C18- A5 F1     1360      LDA NEWC1C1A- 85 F0     1370      STA OLDC1C1C- A9 00     1380      LDA #01C1E- 85 F1     1390      STA NEWC1C20- A2 0A     1400      LDX #10       LEFT MARGIN1C22- A9 A0     1410 PRT2 LDA #$A0      TAB OVER MARGIN1C24- 20 68 1C  1420      JSR POT01C27- CA        1430      DEX1C28- D0 F8     1440      BNE PRT21C2A- A4 F6     1450 PRT3 LDY PRTY      RESTORE X AND Y1C2C- A6 F5     1460      LDX PRTX1C2E- E6 F4     1470      INC LNCT      COUNT THE LINE1C30- A5 F4     1480      LDA LNCT      SEE IF END OF PAGE1C32- C9 38     1490      CMP #56       # LINES PER PAGE1C34- 90 5C     1500      BCC SLW1      NOT END, JOIN FAST LIST1C36- A9 8D     1510      LDA #$8D      YES, OUTPUT CR1C38- 20 F0 FD  1520      JSR COT1      MONITOR OUTPUTC - 2---------------------------------------------------------------------1C3B- A9 00     1530      LDA #0        CLEAR LINE COUNT1C3D- 85 F4     1540      STA LNCT1C3F- F0 5D     1550      BEQ SLW2      JOIN SUSPEND, WAIT FOR KEY                1560 *1C41- A4 F0     1570 PRT5 LDY OLDC      NOT END OF LINE YET1C43- F0 02     1580      BEQ PRT6      PAST PREVIOUS LINE1C45- C5 F0     1590      DEC OLDC1C47- 48        1600 PRT6 PHA           SAVE CHAR1C48- A5 F1     1610 PRT9 LDA NEWC      SEE IF LINE FULL1C4A- C9 46     1620      CMP #70       80-CHAR LINE1C4C- B0 10     1630      BCS PRT7      IGNORE IF EXCESS1C4E- C5 24     1640      CMP CH        SEE IF NEED TAB1C50- B0 07     1650      BCS PRT8      NO1C52- A9 A0     1660      LDA #$A0      SEND BLANKS1C54- 20 66 1C  1670      JSR POUT      TO CATCH UP TO TAB1C57- F0 EF     1680      BEQ PRT9      ...ALWAYS1C59- 68        1690 PRT8 PLA1C5A- 48        1700      PHA1C5B- 20 66 1C  1710      JSR POUT      PRINT IT1C5E- 68        1720 PRT7 PLA           RESTORE CHAR1C5F- A4 F6     1730      LDY PRTY      RESTORE X AND Y1C61- A6 F5     1740      LDX PRTX1C63- 4C F0 FD  1750      JMP COT1      MONITOR OUTPUT                1760 *                1770 *    PRINTER OUTPUT -- 300 BAUD                1780 *1C66- E6 F1     1790 POUT INC NEWC      COUNT THE CHAR1C68- A0 0A     1800 POT0 LDY #10       # BITS TO SEND1C6A- 18        1810      CLC           SET UP FOR START BIT1C6B- 48        1820 POT1 PHA           SAVE CHAR1C6C- B0 05     1830      BCS POT2      1-BIT, SEND MARK1C6E- AD 59 C0  1840      LDA $C059     SPACE1C71- 90 03     1850      BCC POT31C73- AD 58 C0  1860 POT2 LDA $C058     MARK1C76- A9 4D     1870 POT3 LDA #77       TIMING LOOP FOR 300 BAUD1C78- 48        1880 POT4 PHA1C79- A9 20     1890      LDA #$201C7B- 4A        1900 POT5 LSR1C7C- 90 FD     1910      BCC POT51C7E- 68        1920      PLA1C7F- E9 01     1930      SBC #11C81- D0 F5     1940      BNE POT41C83- 68        1950      PLA           GET CHAR (CARRY IS SET)1C84- 6A        1960      ROR           NEXT BIT INTO CARRY1C85- 88        1970      DEY1C86- D0 E3     1980      BNE POT1      SEND NEXT BIT1C88- 60        1990      RTS                2000 *                2010 *    SLOW-LIST ROUTINE                2020 *1C89- C9 8D     2030 SLST CMP #$8D      IS IT CR?1C8B- D0 1F     2040      BNE SLW4      NO, SO PRINT IT1C8D- A9 00     2050      LDA #0        YES, SO SLOW DOWN1C8F- 20 A8 FC  2060      JSR DLAY      MONITOR DELAY ROUTINE1C92- AD 00 C0  2070 SLW1 LDA $C000     CHECK IF KEY TYPED1C95- 10 13     2080      BPL SLW3      NO, OUTPUT CRC - 3---------------------------------------------------------------------1C97- 8D 10 C0  2090      STA $C010     YES, CLEAR STROBE1C9A- C9 8D     2100      CMP #$8D      IS IT CR?1C9C- F0 11     2110      BEQ SLW5      YES, SO ABORT1C9E- AD 00 C0  2120 SLW2 LDA $C000     NO, SO SUSPEND1CA1- 10 FB     2130      BPL SLW2      WAIT FOR KEY1CA3- 8D 10 C0  2140      STA $C010     CLEAR STROBE1CA6- C9 8D     2150      CMP #$8D      IS IT CR?1CA8- F0 05     2160      BEQ SLW5      YES, SO ABORT1CAA- A9 8D     2170 SLW3 LDA #$8D      OUTPUT CR1CAC- 4C F0 FD  2180 SLW4 JMP COT1      MONITOR OUTPUT1CAF- 4C 03 10  2190 SLW5 JMP SOFT      ...ABORT...                2200 *                2210 *    FAST-LIST ROUTINE                2220 *1CB2- C9 8D     2230 FLST CMP #$8D      IS IT CR?1CB4- D0 F6     2240      BNE SLW4      NO, SO KEEP LISTING1CB6- F0 DA     2250      BEQ SLW1      YES, SO CHECK FOR KEYS                2260      .ENSYMBOL TABLECH      0024    OLDC    00F0    NEWC    00F1LNCT    00F4    PRTX    00F5    PRTY    00F6DLAY    FCA8    COT1    FDF0    SOFT    1003PRNT    1C00    PRT1    1C0B    PRT2    1C22PRT3    1C2A    PRT5    1C41    PRT6    1C47PRT9    1C48    PRT8    1C59    PRT7    1C5EPOUT    1C66    POT0    1C68    POT1    1C6BPOT2    1C73    POT3    1C76    POT4    1C78POT5    1C7B    SLST    1C89    SLW1    1C92SLW2    1C9E    SLW3    1CAA    SLW4    1CACSLW5    1CAF    FLST    1CB2C - 4---------------------------------------------------------------------APPENDIX DSources of help with machine language programming are plentiful, butmost of them do not deal with the same microcomputer that is in theApple II.  Here are some that I have found helpful.1.  MC56500 Microcomputer Family Programming Manual, MOS Technology,Inc., 1976.  This is "from the horse's mouth," so you should probablyget one from your computer store.  The same book has been publishedby Synertek and Rockwell, who are both second sources for the 6502chip.2.  Programming the 6502, Rodnay Zaks, SYBEX, 1978.3.  6502 Applications Book, Rodnay Zaks, SYBEX, 1979.4.  How to Program Microcomputers, William Barden, Jr., Howard W.Sams & Co., 1977.  This covers programming for the 8080, 6800, andthe 6502.  It has many simple programs for all three types.5.  Programming a Microcomputer: 6502, Caxton C. Foster,Addison-Wesley Publishing Company, 1978.  Oriented toward the KIM-1,but has very good explanations and examples of the machine language.6.  Apple-II Reference Manual, Apple Computer Company, 1978. Youalready own this one!  It has the complete listing of the AppleROM-based monitor, and several other ROM-based routines.  This is agold mine!7.  MICRO -- The 6502 Journal.  This is a monthly magazine dedicatedto the 6502 microprocessor.  It is published by The COMPUTERIST, P.0. Box 6502, Chelmsford, MA 01824. Subscriptions are currently $15.00per year, or 12 issues.8.  Call-A.P.P.L.E., Apple Pugetsound Program Library Exchange.Another magazine, dedicated strictly to the Apple II.  Free tomembers, and membership is $10; write to 8710 Salty Drive N.W.,Olympia, WA 98502.  Published nine times per year.9.  APPLE-GRAM, the newsletter of the Dallas, Texas, Apple Corps.Subscription is $12/year from The Apple Corps, P. 0. Box 5537,Richardson, TX 75080.D - 1---------------------------------------------------------------------10. The Apple Assembly Line, a newsletter specifically for those whoare using assembly language with their Apple computer. Subscriptionis $12/year from S-C SOFTWARE, P. 0. Box 5537, Richardson, TX 75080.One of the best ways to learn assembly or machine language is toexamine carefully the work of others.  I suggest you use thedis-assembler which is in ROM in your Apple II to disassembleeverything in sight.  Look at how Integer BASIC and Applesoft arecoded.  Look inside S-C ASSEMBLER II and see how it works.  You caneven try making some changes and add in the features you think Ishould have included in the first place!Sources of help with learning to use SWEET-16 are even more limited.Here are the ones I have found:1.  "SWEET-16 -- The 6502 Dream Machine", BYTE, November, 1977, pages150-159.  This is the definitive article written by the creator ofSWEET-16, Steve Wozniak.2.  Apple II Reference Manual, pages 96-99.  This is the assemblylisting of SWEET-16, as found in your Apple II.3.  Programmers Aid #1 Installation and Operating Manual.This is the book that comes with the Programmers Aid #1 ROM.  Itincludes listings of programs coded in SWEET-16 language:Renumber/Append, pages 76-79; and 6502 Relocation Subroutine, pages80-81.4.  Occasional articles in Dr. Dobb's, MICRO, et cetera.D - 2---------------------------------------------------------------------Ads---------------------------------------------------------------------Double Precision Floating Point for APPLESOFTA Brand New Tool for Every Apple Owner!* Apple II or Apple II Plus* Applesoft ROM Card or Language System* 21-digit precision with arithmetic, INPUT, and PRINT* Subroutines for ABS, SQR, LOG, EXP, SIN, COS, and ATN* Efficient and compact assembly language coding:  Only uses 2048 bytes of RAM  Speed comparable to normal Applesoft arithmetic* Automatically loaded beneath your Applesoft program* Nearly standard syntax, simple interface using "&"  feature of Applesoft language* Disk includes nine sample programs* Big 25-page Reference Manual                        Just $50 at your local Apple Dealer!                        Includes diskette with nine sample                        programs and a 25-page reference                        manual.S-C SOFTWARE            *P.O. Box 5537           Apple and Applesoft are trademarksRichardson,TX75080      of the Apple Computer Company.(214) 324-2050---------------------------------------------------------------------S-C ASSEMBLER II            Faster!Version 4.0                   Easier to use!                                More Powerful!New Editing Features* Automatic line numbers,       * Memory use display  with selectable increment.                                * Escape IJKM cursor control* Append programs from disk.      with or without Autostart ROM.* Renumber with selectable      * Two user programmable system  base, increment, and start.     commands.                    * And MUCH MORE!New Assembly Features* FASTER! Up to 6000 lines      * Up to 32-character labels.  per minute!                                     * Use ASCII literals in address* Assembles from multiple         expressions.  source files, using ".IN"  directive.                    * Local labels for more readable                                  modular programs.* Stores object code directly  on binary file, using ".TF"   * Alphabetized symbol table.  directive.                                 * User programmable directive.* Listing control with PG       * Improved error messages, with  (page eject), LIST OFF,         automatic display of bad line  and LIST ON.                  to simplify correction.                    * And MUCH MORE!S-C ASSEMBLER II Version 4.0 is compatible with both the Apple II andthe Apple II Plus. At least 24K RAM is required, and at least onedisk drive.S-C ASSEMBLER II Version 4.0 isavailable now as an upgrade kit only.The upgrade kit includes a documen-         S-C SOFTWAREtation packet and a new diskette, foronly $22.50. Proof of ownership of a        P.O. Box 5537previous disk version is required.          Richardson, TX 75080(Version 3.2 is still available foronly $35.00)                                (214) 324-2050---------------------------------------------------------------------